#ifndef VECTOR_STORAGE_HEADER
#define VECTOR_STORAGE_HEADER

#ifndef VECTOR_STORAGE_LAYOUT_SET
#error "VECTOR_STORAGE_LAYOUT_SET not defined"
#endif

#include "common.comp"

layout(set = VECTOR_STORAGE_LAYOUT_SET, binding = 0)
readonly uniform VectorStorageParams {
    uint dim;
    uint count;
    uint chunk_size;
} vector_storage_params;

#define COUNT vector_storage_params.count

#define DIM vector_storage_params.dim

#define STORAGES_COUNT 4

#define STORAGE(STORAGE_INDEX) CONCAT(vectors, STORAGE_INDEX)

#define VECTOR_STORAGE_DEFINE(STORAGE_INDEX) \
    layout(set = VECTOR_STORAGE_LAYOUT_SET, binding = 1 + STORAGE_INDEX) \
    readonly buffer CONCAT(Vectors, STORAGE_INDEX) { \
        vec4 data[]; \
    } STORAGE(STORAGE_INDEX);

VECTOR_STORAGE_DEFINE(0)
VECTOR_STORAGE_DEFINE(1)
VECTOR_STORAGE_DEFINE(2)
VECTOR_STORAGE_DEFINE(3)

#define VECTOR_STORAGE_SCORE(STORAGE_INDEX_A, STORAGE_INDEX_B) \
    for (uint i = 0; i < d; i++) { \
        result += dot( \
            STORAGE(STORAGE_INDEX_A).data[aId + i], \
            STORAGE(STORAGE_INDEX_B).data[bId + i] \
        ); \
    }

#define VECTOR_STORAGE_SCORE_SUBGROUP(STORAGE_INDEX_A, STORAGE_INDEX_B) \
    for (uint i = 0; i < d; i += SUBGROUP_SIZE, aIndex += SUBGROUP_SIZE, bIndex += SUBGROUP_SIZE) { \
        result += dot( \
            STORAGE(STORAGE_INDEX_A).data[aIndex], \
            STORAGE(STORAGE_INDEX_B).data[bIndex] \
        ); \
    }

float similarity(uint a, uint b) {
    float result = 0.0;
    uint d = DIM / 4;
    uint aIndex = (a / STORAGES_COUNT) * d + SUBGROUP_INVOKATION_ID;
    uint bIndex = (b / STORAGES_COUNT) * d + SUBGROUP_INVOKATION_ID;
    uint storage_index_a = a % STORAGES_COUNT;
    uint storage_index_b = b % STORAGES_COUNT;

    switch (storage_index_a) {
    case 0:
        switch (storage_index_b) {
        case 0:
            VECTOR_STORAGE_SCORE_SUBGROUP(0, 0);
            break;
        case 1:
            VECTOR_STORAGE_SCORE_SUBGROUP(0, 1);
            break;
        case 2:
            VECTOR_STORAGE_SCORE_SUBGROUP(0, 2);
            break;
        case 3:
            VECTOR_STORAGE_SCORE_SUBGROUP(0, 3);
            break;
        }
        break;
    case 1:
        switch (storage_index_b) {
        case 0:
            VECTOR_STORAGE_SCORE_SUBGROUP(1, 0);
            break;
        case 1:
            VECTOR_STORAGE_SCORE_SUBGROUP(1, 1);
            break;
        case 2:
            VECTOR_STORAGE_SCORE_SUBGROUP(1, 2);
            break;
        case 3:
            VECTOR_STORAGE_SCORE_SUBGROUP(1, 3);
            break;
        }
        break;
    case 2:
        switch (storage_index_b) {
        case 0:
            VECTOR_STORAGE_SCORE_SUBGROUP(2, 0);
            break;
        case 1:
            VECTOR_STORAGE_SCORE_SUBGROUP(2, 1);
            break;
        case 2:
            VECTOR_STORAGE_SCORE_SUBGROUP(2, 2);
            break;
        case 3:
            VECTOR_STORAGE_SCORE_SUBGROUP(2, 3);
            break;
        }
        break;
    case 3:
        switch (storage_index_b) {
        case 0:
            VECTOR_STORAGE_SCORE_SUBGROUP(3, 0);
            break;
        case 1:
            VECTOR_STORAGE_SCORE_SUBGROUP(3, 1);
            break;
        case 2:
            VECTOR_STORAGE_SCORE_SUBGROUP(3, 2);
            break;
        case 3:
            VECTOR_STORAGE_SCORE_SUBGROUP(3, 3);
            break;
        }
        break;
    }

    return subgroupAdd(result);
}

float similarity_obsolete(uint a, uint b) {
    mat4 result = mat4(0.0);
    uint d = DIM / 4;
    uint aId = (a / STORAGES_COUNT) * d;
    uint bId = (b / STORAGES_COUNT) * d;
    uint storage_index_a = a % STORAGES_COUNT;
    uint storage_index_b = b % STORAGES_COUNT;

    switch (storage_index_a) {
    case 0:
        switch (storage_index_b) {
        case 0:
            VECTOR_STORAGE_SCORE(0, 0);
            break;
        case 1:
            VECTOR_STORAGE_SCORE(0, 1);
            break;
        case 2:
            VECTOR_STORAGE_SCORE(0, 2);
            break;
        case 3:
            VECTOR_STORAGE_SCORE(0, 3);
            break;
        }
        break;
    case 1:
        switch (storage_index_b) {
        case 0:
            VECTOR_STORAGE_SCORE(1, 0);
            break;
        case 1:
            VECTOR_STORAGE_SCORE(1, 1);
            break;
        case 2:
            VECTOR_STORAGE_SCORE(1, 2);
            break;
        case 3:
            VECTOR_STORAGE_SCORE(1, 3);
            break;
        }
        break;
    case 2:
        switch (storage_index_b) {
        case 0:
            VECTOR_STORAGE_SCORE(2, 0);
            break;
        case 1:
            VECTOR_STORAGE_SCORE(2, 1);
            break;
        case 2:
            VECTOR_STORAGE_SCORE(2, 2);
            break;
        case 3:
            VECTOR_STORAGE_SCORE(2, 3);
            break;
        }
        break;
    case 3:
        switch (storage_index_b) {
        case 0:
            VECTOR_STORAGE_SCORE(3, 0);
            break;
        case 1:
            VECTOR_STORAGE_SCORE(3, 1);
            break;
        case 2:
            VECTOR_STORAGE_SCORE(3, 2);
            break;
        case 3:
            VECTOR_STORAGE_SCORE(3, 3);
            break;
        }
        break;
    }

    vec4 v1 = result[0];
    vec4 v2 = result[1];
    vec4 v3 = result[2];
    vec4 v4 = result[3];
    return v1.x + v1.y + v1.z + v1.w
         + v2.x + v2.y + v2.z + v2.w
         + v3.x + v3.y + v3.z + v3.w
         + v4.x + v4.y + v4.z + v4.w;
}

#endif

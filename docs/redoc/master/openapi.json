{
  "components": {
    "schemas": {
      "AliasOperations": {
        "anyOf": [
          {
            "$ref": "#/components/schemas/CreateAliasOperation"
          },
          {
            "$ref": "#/components/schemas/DeleteAliasOperation"
          },
          {
            "$ref": "#/components/schemas/RenameAliasOperation"
          }
        ],
        "description": "Group of all the possible operations related to collection aliases"
      },
      "Batch": {
        "properties": {
          "ids": {
            "items": {
              "$ref": "#/components/schemas/ExtendedPointId"
            },
            "type": "array"
          },
          "payloads": {
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/Payload"
                },
                {
                  "nullable": true
                }
              ]
            },
            "nullable": true,
            "type": "array"
          },
          "vectors": {
            "items": {
              "items": {
                "format": "float",
                "type": "number"
              },
              "type": "array"
            },
            "type": "array"
          }
        },
        "required": [
          "ids",
          "vectors"
        ],
        "type": "object"
      },
      "ChangeAliasesOperation": {
        "description": "Operation for performing changes of collection aliases. Alias changes are atomic, meaning that no collection modifications can happen between alias operations.",
        "properties": {
          "actions": {
            "items": {
              "$ref": "#/components/schemas/AliasOperations"
            },
            "type": "array"
          }
        },
        "required": [
          "actions"
        ],
        "type": "object"
      },
      "CollectionConfig": {
        "properties": {
          "hnsw_config": {
            "$ref": "#/components/schemas/HnswConfig"
          },
          "optimizer_config": {
            "$ref": "#/components/schemas/OptimizersConfig"
          },
          "params": {
            "$ref": "#/components/schemas/CollectionParams"
          },
          "wal_config": {
            "$ref": "#/components/schemas/WalConfig"
          }
        },
        "required": [
          "hnsw_config",
          "optimizer_config",
          "params",
          "wal_config"
        ],
        "type": "object"
      },
      "CollectionDescription": {
        "properties": {
          "name": {
            "type": "string"
          }
        },
        "required": [
          "name"
        ],
        "type": "object"
      },
      "CollectionInfo": {
        "description": "Current statistics and configuration of the collection",
        "properties": {
          "config": {
            "$ref": "#/components/schemas/CollectionConfig"
          },
          "disk_data_size": {
            "description": "Disk space, used by collection",
            "format": "uint",
            "minimum": 0,
            "type": "integer"
          },
          "optimizer_status": {
            "$ref": "#/components/schemas/OptimizersStatus"
          },
          "payload_schema": {
            "additionalProperties": {
              "$ref": "#/components/schemas/PayloadIndexInfo"
            },
            "description": "Types of stored payload",
            "type": "object"
          },
          "ram_data_size": {
            "description": "RAM used by collection",
            "format": "uint",
            "minimum": 0,
            "type": "integer"
          },
          "segments_count": {
            "description": "Number of segments in collection",
            "format": "uint",
            "minimum": 0,
            "type": "integer"
          },
          "status": {
            "$ref": "#/components/schemas/CollectionStatus"
          },
          "vectors_count": {
            "description": "Number of vectors in collection",
            "format": "uint",
            "minimum": 0,
            "type": "integer"
          }
        },
        "required": [
          "config",
          "disk_data_size",
          "optimizer_status",
          "payload_schema",
          "ram_data_size",
          "segments_count",
          "status",
          "vectors_count"
        ],
        "type": "object"
      },
      "CollectionParams": {
        "properties": {
          "distance": {
            "$ref": "#/components/schemas/Distance"
          },
          "shard_number": {
            "default": 1,
            "description": "Number of shards the collection has",
            "format": "uint32",
            "minimum": 1,
            "type": "integer"
          },
          "vector_size": {
            "description": "Size of a vectors used",
            "format": "uint",
            "minimum": 0,
            "type": "integer"
          }
        },
        "required": [
          "distance",
          "vector_size"
        ],
        "type": "object"
      },
      "CollectionStatus": {
        "description": "Current state of the collection",
        "enum": [
          "green",
          "yellow",
          "red"
        ],
        "type": "string"
      },
      "CollectionUpdateOperations": {
        "anyOf": [
          {
            "$ref": "#/components/schemas/PointOperations"
          },
          {
            "$ref": "#/components/schemas/PayloadOps"
          },
          {
            "$ref": "#/components/schemas/FieldIndexOperations"
          }
        ]
      },
      "CollectionsResponse": {
        "properties": {
          "collections": {
            "items": {
              "$ref": "#/components/schemas/CollectionDescription"
            },
            "type": "array"
          }
        },
        "required": [
          "collections"
        ],
        "type": "object"
      },
      "Condition": {
        "anyOf": [
          {
            "$ref": "#/components/schemas/FieldCondition"
          },
          {
            "$ref": "#/components/schemas/HasIdCondition"
          },
          {
            "$ref": "#/components/schemas/Filter"
          }
        ]
      },
      "CreateAlias": {
        "description": "Create alternative name for a collection. Collection will be available under both names for search, retrieve,",
        "properties": {
          "alias_name": {
            "type": "string"
          },
          "collection_name": {
            "type": "string"
          }
        },
        "required": [
          "alias_name",
          "collection_name"
        ],
        "type": "object"
      },
      "CreateAliasOperation": {
        "properties": {
          "create_alias": {
            "$ref": "#/components/schemas/CreateAlias"
          }
        },
        "required": [
          "create_alias"
        ],
        "type": "object"
      },
      "CreateCollection": {
        "description": "Operation for creating new collection and (optionally) specify index params",
        "properties": {
          "distance": {
            "$ref": "#/components/schemas/Distance"
          },
          "hnsw_config": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/HnswConfigDiff"
              },
              {
                "nullable": true
              }
            ],
            "description": "Custom params for HNSW index. If none - values from service configuration file are used."
          },
          "optimizers_config": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/OptimizersConfigDiff"
              },
              {
                "nullable": true
              }
            ],
            "description": "Custom params for Optimizers.  If none - values from service configuration file are used."
          },
          "shard_number": {
            "default": 1,
            "description": "Number of shards in collection. Default is 1, minimum is 1.",
            "format": "uint32",
            "minimum": 0,
            "type": "integer"
          },
          "vector_size": {
            "format": "uint",
            "minimum": 0,
            "type": "integer"
          },
          "wal_config": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/WalConfigDiff"
              },
              {
                "nullable": true
              }
            ],
            "description": "Custom params for WAL. If none - values from service configuration file are used."
          }
        },
        "required": [
          "distance",
          "vector_size"
        ],
        "type": "object"
      },
      "CreateCollectionOperation": {
        "description": "Operation for creating new collection and (optionally) specify index params",
        "properties": {
          "collection_name": {
            "type": "string"
          },
          "distance": {
            "$ref": "#/components/schemas/Distance"
          },
          "hnsw_config": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/HnswConfigDiff"
              },
              {
                "nullable": true
              }
            ],
            "description": "Custom params for HNSW index. If none - values from service configuration file are used."
          },
          "optimizers_config": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/OptimizersConfigDiff"
              },
              {
                "nullable": true
              }
            ],
            "description": "Custom params for Optimizers.  If none - values from service configuration file are used."
          },
          "shard_number": {
            "default": 1,
            "description": "Number of shards in collection. Default is 1, minimum is 1.",
            "format": "uint32",
            "minimum": 0,
            "type": "integer"
          },
          "vector_size": {
            "format": "uint",
            "minimum": 0,
            "type": "integer"
          },
          "wal_config": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/WalConfigDiff"
              },
              {
                "nullable": true
              }
            ],
            "description": "Custom params for WAL. If none - values from service configuration file are used."
          }
        },
        "required": [
          "collection_name",
          "distance",
          "vector_size"
        ],
        "type": "object"
      },
      "CreateFieldIndex": {
        "properties": {
          "field_name": {
            "type": "string"
          },
          "field_type": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/PayloadSchemaType"
              },
              {
                "nullable": true
              }
            ]
          }
        },
        "required": [
          "field_name"
        ],
        "type": "object"
      },
      "CreateIndex": {
        "properties": {
          "field_name": {
            "type": "string"
          },
          "field_type": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/PayloadSchemaType"
              },
              {
                "nullable": true
              }
            ]
          }
        },
        "required": [
          "field_name"
        ],
        "type": "object"
      },
      "DeleteAlias": {
        "description": "Delete alias if exists",
        "properties": {
          "alias_name": {
            "type": "string"
          }
        },
        "required": [
          "alias_name"
        ],
        "type": "object"
      },
      "DeleteAliasOperation": {
        "description": "Delete alias if exists",
        "properties": {
          "delete_alias": {
            "$ref": "#/components/schemas/DeleteAlias"
          }
        },
        "required": [
          "delete_alias"
        ],
        "type": "object"
      },
      "DeleteCollectionOperation": {
        "description": "Operation for deleting collection with given name",
        "type": "string"
      },
      "DeletePayload": {
        "properties": {
          "keys": {
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "points": {
            "description": "Deletes values from each point in this list",
            "items": {
              "$ref": "#/components/schemas/ExtendedPointId"
            },
            "type": "array"
          }
        },
        "required": [
          "keys",
          "points"
        ],
        "type": "object"
      },
      "Distance": {
        "description": "Type of internal tags, build from payload Distance function types used to compare vectors",
        "enum": [
          "Cosine",
          "Euclid",
          "Dot"
        ],
        "type": "string"
      },
      "ErrorResponse": {
        "properties": {
          "result": {
            "nullable": true,
            "type": "object"
          },
          "status": {
            "properties": {
              "error": {
                "description": "Description of the occurred error.",
                "type": "string"
              }
            },
            "type": "object"
          },
          "time": {
            "description": "Time spent to process this request",
            "format": "float",
            "type": "number"
          }
        },
        "type": "object"
      },
      "ExtendedPointId": {
        "anyOf": [
          {
            "format": "uint64",
            "minimum": 0,
            "type": "integer"
          },
          {
            "format": "uuid",
            "type": "string"
          }
        ],
        "description": "Type, used for specifying point ID in user interface"
      },
      "FieldCondition": {
        "description": "All possible payload filtering conditions",
        "properties": {
          "geo_bounding_box": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/GeoBoundingBox"
              },
              {
                "nullable": true
              }
            ],
            "description": "Check if points geo location lies in a given area"
          },
          "geo_radius": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/GeoRadius"
              },
              {
                "nullable": true
              }
            ],
            "description": "Check if geo point is within a given radius"
          },
          "key": {
            "type": "string"
          },
          "match": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/Match"
              },
              {
                "nullable": true
              }
            ],
            "description": "Check if point has field with a given value"
          },
          "range": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/Range"
              },
              {
                "nullable": true
              }
            ],
            "description": "Check if points value lies in a given range"
          }
        },
        "required": [
          "key"
        ],
        "type": "object"
      },
      "FieldIndexOperations": {
        "oneOf": [
          {
            "additionalProperties": false,
            "description": "Create index for payload field",
            "properties": {
              "create_index": {
                "$ref": "#/components/schemas/CreateIndex"
              }
            },
            "required": [
              "create_index"
            ],
            "type": "object"
          },
          {
            "additionalProperties": false,
            "description": "Delete index for the field",
            "properties": {
              "delete_index": {
                "type": "string"
              }
            },
            "required": [
              "delete_index"
            ],
            "type": "object"
          }
        ]
      },
      "Filter": {
        "additionalProperties": false,
        "properties": {
          "must": {
            "description": "All conditions must match",
            "items": {
              "$ref": "#/components/schemas/Condition"
            },
            "nullable": true,
            "type": "array"
          },
          "must_not": {
            "description": "All conditions must NOT match",
            "items": {
              "$ref": "#/components/schemas/Condition"
            },
            "nullable": true,
            "type": "array"
          },
          "should": {
            "description": "At least one of thous conditions should match",
            "items": {
              "$ref": "#/components/schemas/Condition"
            },
            "nullable": true,
            "type": "array"
          }
        },
        "type": "object"
      },
      "FilterSelector": {
        "properties": {
          "filter": {
            "$ref": "#/components/schemas/Filter"
          }
        },
        "required": [
          "filter"
        ],
        "type": "object"
      },
      "GeoBoundingBox": {
        "description": "Geo filter request\n\nMatches coordinates inside the rectangle, described by coordinates of lop-left and bottom-right edges",
        "properties": {
          "bottom_right": {
            "$ref": "#/components/schemas/GeoPoint"
          },
          "top_left": {
            "$ref": "#/components/schemas/GeoPoint"
          }
        },
        "required": [
          "bottom_right",
          "top_left"
        ],
        "type": "object"
      },
      "GeoPoint": {
        "description": "Geo point payload schema",
        "properties": {
          "lat": {
            "format": "double",
            "type": "number"
          },
          "lon": {
            "format": "double",
            "type": "number"
          }
        },
        "required": [
          "lat",
          "lon"
        ],
        "type": "object"
      },
      "GeoRadius": {
        "description": "Geo filter request\n\nMatches coordinates inside the circle of `radius` and center with coordinates `center`",
        "properties": {
          "center": {
            "$ref": "#/components/schemas/GeoPoint"
          },
          "radius": {
            "description": "Radius of the area in meters",
            "format": "double",
            "type": "number"
          }
        },
        "required": [
          "center",
          "radius"
        ],
        "type": "object"
      },
      "HasIdCondition": {
        "description": "ID-based filtering condition",
        "properties": {
          "has_id": {
            "items": {
              "$ref": "#/components/schemas/ExtendedPointId"
            },
            "type": "array",
            "uniqueItems": true
          }
        },
        "required": [
          "has_id"
        ],
        "type": "object"
      },
      "HnswConfig": {
        "description": "Config of HNSW index",
        "properties": {
          "ef_construct": {
            "description": "Number of neighbours to consider during the index building. Larger the value - more accurate the search, more time required to build index.",
            "format": "uint",
            "minimum": 0,
            "type": "integer"
          },
          "full_scan_threshold": {
            "description": "Minimal amount of points for additional payload-based indexing. If payload chunk is smaller than `full_scan_threshold` additional indexing won't be used - in this case full-scan search should be preferred by query planner and additional indexing is not required.",
            "format": "uint",
            "minimum": 0,
            "type": "integer"
          },
          "m": {
            "description": "Number of edges per node in the index graph. Larger the value - more accurate the search, more space required.",
            "format": "uint",
            "minimum": 0,
            "type": "integer"
          }
        },
        "required": [
          "ef_construct",
          "full_scan_threshold",
          "m"
        ],
        "type": "object"
      },
      "HnswConfigDiff": {
        "properties": {
          "ef_construct": {
            "description": "Number of neighbours to consider during the index building. Larger the value - more accurate the search, more time required to build index.",
            "format": "uint",
            "minimum": 0,
            "nullable": true,
            "type": "integer"
          },
          "full_scan_threshold": {
            "description": "Minimal amount of points for additional payload-based indexing. If payload chunk is smaller than `full_scan_threshold` additional indexing won't be used - in this case full-scan search should be preferred by query planner and additional indexing is not required.",
            "format": "uint",
            "minimum": 0,
            "nullable": true,
            "type": "integer"
          },
          "m": {
            "description": "Number of edges per node in the index graph. Larger the value - more accurate the search, more space required.",
            "format": "uint",
            "minimum": 0,
            "nullable": true,
            "type": "integer"
          }
        },
        "type": "object"
      },
      "Match": {
        "anyOf": [
          {
            "$ref": "#/components/schemas/MatchKeyword"
          },
          {
            "$ref": "#/components/schemas/MatchInteger"
          }
        ],
        "description": "Match filter request"
      },
      "MatchInteger": {
        "description": "Match filter request",
        "properties": {
          "integer": {
            "description": "Integer value to match",
            "format": "int64",
            "type": "integer"
          }
        },
        "required": [
          "integer"
        ],
        "type": "object"
      },
      "MatchKeyword": {
        "description": "Match by keyword",
        "properties": {
          "keyword": {
            "description": "Keyword value to match",
            "type": "string"
          }
        },
        "required": [
          "keyword"
        ],
        "type": "object"
      },
      "OptimizersConfig": {
        "properties": {
          "default_segment_number": {
            "description": "Target amount of segments optimizer will try to keep. Real amount of segments may vary depending on multiple parameters: - Amount of stored points - Current write RPS\n\nIt is recommended to select default number of segments as a factor of the number of search threads, so that each segment would be handled evenly by one of the threads",
            "format": "uint",
            "minimum": 0,
            "type": "integer"
          },
          "deleted_threshold": {
            "description": "The minimal fraction of deleted vectors in a segment, required to perform segment optimization",
            "format": "double",
            "type": "number"
          },
          "flush_interval_sec": {
            "description": "Minimum interval between forced flushes.",
            "format": "uint64",
            "minimum": 0,
            "type": "integer"
          },
          "indexing_threshold": {
            "description": "Maximum number of vectors allowed for plain index. Default value based on https://github.com/google-research/google-research/blob/master/scann/docs/algorithms.md",
            "format": "uint",
            "minimum": 0,
            "type": "integer"
          },
          "max_optimization_threads": {
            "description": "Maximum available threads for optimization workers",
            "format": "uint",
            "minimum": 0,
            "type": "integer"
          },
          "max_segment_size": {
            "description": "Do not create segments larger this number of points. Large segments might require disproportionately long indexation times, therefore it makes sense to limit the size of segments.\n\nIf indexation speed have more priority for your - make this parameter lower. If search speed is more important - make this parameter higher.",
            "format": "uint",
            "minimum": 0,
            "type": "integer"
          },
          "memmap_threshold": {
            "description": "Maximum number of vectors to store in-memory per segment. Segments larger than this threshold will be stored as read-only memmaped file.",
            "format": "uint",
            "minimum": 0,
            "type": "integer"
          },
          "payload_indexing_threshold": {
            "description": "Starting from this amount of vectors per-segment the engine will start building index for payload.",
            "format": "uint",
            "minimum": 0,
            "type": "integer"
          },
          "vacuum_min_vector_number": {
            "description": "The minimal number of vectors in a segment, required to perform segment optimization",
            "format": "uint",
            "minimum": 0,
            "type": "integer"
          }
        },
        "required": [
          "default_segment_number",
          "deleted_threshold",
          "flush_interval_sec",
          "indexing_threshold",
          "max_optimization_threads",
          "max_segment_size",
          "memmap_threshold",
          "payload_indexing_threshold",
          "vacuum_min_vector_number"
        ],
        "type": "object"
      },
      "OptimizersConfigDiff": {
        "properties": {
          "default_segment_number": {
            "description": "Target amount of segments optimizer will try to keep. Real amount of segments may vary depending on multiple parameters: - Amount of stored points - Current write RPS\n\nIt is recommended to select default number of segments as a factor of the number of search threads, so that each segment would be handled evenly by one of the threads",
            "format": "uint",
            "minimum": 0,
            "nullable": true,
            "type": "integer"
          },
          "deleted_threshold": {
            "description": "The minimal fraction of deleted vectors in a segment, required to perform segment optimization",
            "format": "double",
            "nullable": true,
            "type": "number"
          },
          "flush_interval_sec": {
            "description": "Minimum interval between forced flushes.",
            "format": "uint64",
            "minimum": 0,
            "nullable": true,
            "type": "integer"
          },
          "indexing_threshold": {
            "description": "Maximum number of vectors allowed for plain index. Default value based on https://github.com/google-research/google-research/blob/master/scann/docs/algorithms.md",
            "format": "uint",
            "minimum": 0,
            "nullable": true,
            "type": "integer"
          },
          "max_optimization_threads": {
            "description": "Maximum available threads for optimization workers",
            "format": "uint",
            "minimum": 0,
            "nullable": true,
            "type": "integer"
          },
          "max_segment_size": {
            "description": "Do not create segments larger this number of points. Large segments might require disproportionately long indexation times, therefore it makes sense to limit the size of segments.\n\nIf indexation speed have more priority for your - make this parameter lower. If search speed is more important - make this parameter higher.",
            "format": "uint",
            "minimum": 0,
            "nullable": true,
            "type": "integer"
          },
          "memmap_threshold": {
            "description": "Maximum number of vectors to store in-memory per segment. Segments larger than this threshold will be stored as read-only memmaped file.",
            "format": "uint",
            "minimum": 0,
            "nullable": true,
            "type": "integer"
          },
          "payload_indexing_threshold": {
            "description": "Starting from this amount of vectors per-segment the engine will start building index for payload.",
            "format": "uint",
            "minimum": 0,
            "nullable": true,
            "type": "integer"
          },
          "vacuum_min_vector_number": {
            "description": "The minimal number of vectors in a segment, required to perform segment optimization",
            "format": "uint",
            "minimum": 0,
            "nullable": true,
            "type": "integer"
          }
        },
        "type": "object"
      },
      "OptimizersStatus": {
        "description": "Current state of the collection",
        "oneOf": [
          {
            "enum": [
              "ok"
            ],
            "type": "string"
          },
          {
            "additionalProperties": false,
            "description": "Something wrong happened with optimizers",
            "properties": {
              "error": {
                "type": "string"
              }
            },
            "required": [
              "error"
            ],
            "type": "object"
          }
        ]
      },
      "Payload": {
        "additionalProperties": true,
        "type": "object"
      },
      "PayloadIndexInfo": {
        "description": "Payload field type & index information",
        "properties": {
          "data_type": {
            "$ref": "#/components/schemas/PayloadSchemaType"
          }
        },
        "required": [
          "data_type"
        ],
        "type": "object"
      },
      "PayloadOps": {
        "description": "Define operations description for point payloads manipulation",
        "oneOf": [
          {
            "additionalProperties": false,
            "description": "Set payload value, overrides if it is already exists",
            "properties": {
              "set_payload": {
                "$ref": "#/components/schemas/SetPayload"
              }
            },
            "required": [
              "set_payload"
            ],
            "type": "object"
          },
          {
            "additionalProperties": false,
            "description": "Deletes specified payload values if they are assigned",
            "properties": {
              "delete_payload": {
                "$ref": "#/components/schemas/DeletePayload"
              }
            },
            "required": [
              "delete_payload"
            ],
            "type": "object"
          },
          {
            "additionalProperties": false,
            "description": "Drops all Payload values associated with given points.",
            "properties": {
              "clear_payload": {
                "properties": {
                  "points": {
                    "items": {
                      "$ref": "#/components/schemas/ExtendedPointId"
                    },
                    "type": "array"
                  }
                },
                "required": [
                  "points"
                ],
                "type": "object"
              }
            },
            "required": [
              "clear_payload"
            ],
            "type": "object"
          },
          {
            "additionalProperties": false,
            "description": "Clear all Payload values by given filter criteria.",
            "properties": {
              "clear_payload_by_filter": {
                "$ref": "#/components/schemas/Filter"
              }
            },
            "required": [
              "clear_payload_by_filter"
            ],
            "type": "object"
          }
        ]
      },
      "PayloadSchemaType": {
        "description": "All possible names of payload types",
        "enum": [
          "keyword",
          "integer",
          "float",
          "geo"
        ],
        "type": "string"
      },
      "PayloadSelector": {
        "anyOf": [
          {
            "$ref": "#/components/schemas/PayloadSelectorInclude"
          },
          {
            "$ref": "#/components/schemas/PayloadSelectorExclude"
          }
        ],
        "description": "Specifies how to treat payload selector"
      },
      "PayloadSelectorExclude": {
        "additionalProperties": false,
        "properties": {
          "exclude": {
            "description": "Exclude this fields from returning payload",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "required": [
          "exclude"
        ],
        "type": "object"
      },
      "PayloadSelectorInclude": {
        "additionalProperties": false,
        "properties": {
          "include": {
            "description": "Only include this payload keys",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "required": [
          "include"
        ],
        "type": "object"
      },
      "PointIdsList": {
        "properties": {
          "points": {
            "items": {
              "$ref": "#/components/schemas/ExtendedPointId"
            },
            "type": "array"
          }
        },
        "required": [
          "points"
        ],
        "type": "object"
      },
      "PointInsertOperations": {
        "anyOf": [
          {
            "$ref": "#/components/schemas/PointsBatch"
          },
          {
            "$ref": "#/components/schemas/PointsList"
          }
        ]
      },
      "PointOperations": {
        "oneOf": [
          {
            "additionalProperties": false,
            "description": "Insert or update points",
            "properties": {
              "upsert_points": {
                "$ref": "#/components/schemas/PointInsertOperations"
              }
            },
            "required": [
              "upsert_points"
            ],
            "type": "object"
          },
          {
            "additionalProperties": false,
            "description": "Delete point if exists",
            "properties": {
              "delete_points": {
                "properties": {
                  "ids": {
                    "items": {
                      "$ref": "#/components/schemas/ExtendedPointId"
                    },
                    "type": "array"
                  }
                },
                "required": [
                  "ids"
                ],
                "type": "object"
              }
            },
            "required": [
              "delete_points"
            ],
            "type": "object"
          },
          {
            "additionalProperties": false,
            "description": "Delete points by given filter criteria",
            "properties": {
              "delete_points_by_filter": {
                "$ref": "#/components/schemas/Filter"
              }
            },
            "required": [
              "delete_points_by_filter"
            ],
            "type": "object"
          }
        ]
      },
      "PointRequest": {
        "properties": {
          "ids": {
            "description": "Look for points with ids",
            "items": {
              "$ref": "#/components/schemas/ExtendedPointId"
            },
            "type": "array"
          },
          "with_payload": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/WithPayloadInterface"
              },
              {
                "nullable": true
              }
            ],
            "description": "Select which payload to return with the response. Default: All"
          },
          "with_vector": {
            "default": false,
            "description": "Whether to return the point vector with the result?",
            "type": "boolean"
          }
        },
        "required": [
          "ids"
        ],
        "type": "object"
      },
      "PointStruct": {
        "properties": {
          "id": {
            "$ref": "#/components/schemas/ExtendedPointId"
          },
          "payload": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/Payload"
              },
              {
                "nullable": true
              }
            ],
            "description": "Payload values (optional)"
          },
          "vector": {
            "description": "Vector",
            "items": {
              "format": "float",
              "type": "number"
            },
            "type": "array"
          }
        },
        "required": [
          "id",
          "vector"
        ],
        "type": "object"
      },
      "PointsBatch": {
        "properties": {
          "batch": {
            "$ref": "#/components/schemas/Batch"
          }
        },
        "required": [
          "batch"
        ],
        "type": "object"
      },
      "PointsList": {
        "properties": {
          "points": {
            "items": {
              "$ref": "#/components/schemas/PointStruct"
            },
            "type": "array"
          }
        },
        "required": [
          "points"
        ],
        "type": "object"
      },
      "PointsSelector": {
        "anyOf": [
          {
            "$ref": "#/components/schemas/PointIdsList"
          },
          {
            "$ref": "#/components/schemas/FilterSelector"
          }
        ]
      },
      "Range": {
        "description": "Range filter request",
        "properties": {
          "gt": {
            "description": "point.key > range.gt",
            "format": "double",
            "nullable": true,
            "type": "number"
          },
          "gte": {
            "description": "point.key >= range.gte",
            "format": "double",
            "nullable": true,
            "type": "number"
          },
          "lt": {
            "description": "point.key < range.lt",
            "format": "double",
            "nullable": true,
            "type": "number"
          },
          "lte": {
            "description": "point.key <= range.lte",
            "format": "double",
            "nullable": true,
            "type": "number"
          }
        },
        "type": "object"
      },
      "RecommendRequest": {
        "description": "Recommendation request. Provides positive and negative examples of the vectors, which are already stored in the collection.\n\nService should look for the points which are closer to positive examples and at the same time further to negative examples. The concrete way of how to compare negative and positive distances is up to implementation in `segment` crate.",
        "properties": {
          "filter": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/Filter"
              },
              {
                "nullable": true
              }
            ],
            "description": "Look only for points which satisfies this conditions"
          },
          "negative": {
            "description": "Try to avoid vectors like this",
            "items": {
              "$ref": "#/components/schemas/ExtendedPointId"
            },
            "type": "array"
          },
          "params": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SearchParams"
              },
              {
                "nullable": true
              }
            ],
            "description": "Additional search params"
          },
          "positive": {
            "description": "Look for vectors closest to those",
            "items": {
              "$ref": "#/components/schemas/ExtendedPointId"
            },
            "type": "array"
          },
          "top": {
            "description": "Max number of result to return",
            "format": "uint",
            "minimum": 0,
            "type": "integer"
          },
          "with_payload": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/WithPayloadInterface"
              },
              {
                "nullable": true
              }
            ],
            "description": "Select which payload to return with the response. Default: None"
          },
          "with_vector": {
            "default": false,
            "description": "Whether to return the point vector with the result?",
            "type": "boolean"
          }
        },
        "required": [
          "negative",
          "positive",
          "top"
        ],
        "type": "object"
      },
      "Record": {
        "description": "Point data",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/ExtendedPointId"
          },
          "payload": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/Payload"
              },
              {
                "nullable": true
              }
            ],
            "description": "Payload - values assigned to the point"
          },
          "vector": {
            "description": "Vector of the point",
            "items": {
              "format": "float",
              "type": "number"
            },
            "nullable": true,
            "type": "array"
          }
        },
        "required": [
          "id"
        ],
        "type": "object"
      },
      "RenameAlias": {
        "description": "Change alias to a new one",
        "properties": {
          "new_alias_name": {
            "type": "string"
          },
          "old_alias_name": {
            "type": "string"
          }
        },
        "required": [
          "new_alias_name",
          "old_alias_name"
        ],
        "type": "object"
      },
      "RenameAliasOperation": {
        "description": "Change alias to a new one",
        "properties": {
          "rename_alias": {
            "$ref": "#/components/schemas/RenameAlias"
          }
        },
        "required": [
          "rename_alias"
        ],
        "type": "object"
      },
      "ScoredPoint": {
        "description": "Search result",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/ExtendedPointId"
          },
          "payload": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/Payload"
              },
              {
                "nullable": true
              }
            ],
            "description": "Payload - values assigned to the point"
          },
          "score": {
            "description": "Points vector distance to the query vector",
            "format": "float",
            "type": "number"
          },
          "vector": {
            "description": "Vector of the point",
            "items": {
              "format": "float",
              "type": "number"
            },
            "nullable": true,
            "type": "array"
          },
          "version": {
            "description": "Point version",
            "format": "uint64",
            "minimum": 0,
            "type": "integer"
          }
        },
        "required": [
          "id",
          "score",
          "version"
        ],
        "type": "object"
      },
      "ScrollRequest": {
        "description": "Scroll request - paginate over all points which matches given condition",
        "properties": {
          "filter": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/Filter"
              },
              {
                "nullable": true
              }
            ],
            "description": "Look only for points which satisfies this conditions. If not provided - all points."
          },
          "limit": {
            "description": "Page size. Default: 10",
            "format": "uint",
            "minimum": 0,
            "nullable": true,
            "type": "integer"
          },
          "offset": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ExtendedPointId"
              },
              {
                "nullable": true
              }
            ],
            "description": "Start ID to read points from."
          },
          "with_payload": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/WithPayloadInterface"
              },
              {
                "nullable": true
              }
            ],
            "description": "Select which payload to return with the response. Default: All"
          },
          "with_vector": {
            "default": false,
            "description": "Whether to return the point vector with the result?",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "ScrollResult": {
        "description": "Result of the points read request",
        "properties": {
          "next_page_offset": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ExtendedPointId"
              },
              {
                "nullable": true
              }
            ],
            "description": "Offset which should be used to retrieve a next page result"
          },
          "points": {
            "description": "List of retrieved points",
            "items": {
              "$ref": "#/components/schemas/Record"
            },
            "type": "array"
          }
        },
        "required": [
          "points"
        ],
        "type": "object"
      },
      "SearchParams": {
        "description": "Additional parameters of the search",
        "properties": {
          "hnsw_ef": {
            "description": "Params relevant to HNSW index /// Size of the beam in a beam-search. Larger the value - more accurate the result, more time required for search.",
            "format": "uint",
            "minimum": 0,
            "nullable": true,
            "type": "integer"
          }
        },
        "type": "object"
      },
      "SearchRequest": {
        "description": "Search request. Holds all conditions and parameters for the search of most similar points by vector similarity given the filtering restrictions.",
        "properties": {
          "filter": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/Filter"
              },
              {
                "nullable": true
              }
            ],
            "description": "Look only for points which satisfies this conditions"
          },
          "params": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SearchParams"
              },
              {
                "nullable": true
              }
            ],
            "description": "Additional search params"
          },
          "top": {
            "description": "Max number of result to return",
            "format": "uint",
            "minimum": 0,
            "type": "integer"
          },
          "vector": {
            "description": "Look for vectors closest to this",
            "items": {
              "format": "float",
              "type": "number"
            },
            "type": "array"
          },
          "with_payload": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/WithPayloadInterface"
              },
              {
                "nullable": true
              }
            ],
            "description": "Select which payload to return with the response. Default: None"
          },
          "with_vector": {
            "default": false,
            "description": "Whether to return the point vector with the result?",
            "type": "boolean"
          }
        },
        "required": [
          "top",
          "vector"
        ],
        "type": "object"
      },
      "SetPayload": {
        "properties": {
          "payload": {
            "$ref": "#/components/schemas/Payload"
          },
          "points": {
            "description": "Assigns payload to each point in this list",
            "items": {
              "$ref": "#/components/schemas/ExtendedPointId"
            },
            "type": "array"
          }
        },
        "required": [
          "payload",
          "points"
        ],
        "type": "object"
      },
      "StorageOperations": {
        "description": "Enumeration of all possible collection update operations",
        "oneOf": [
          {
            "additionalProperties": false,
            "properties": {
              "create_collection": {
                "$ref": "#/components/schemas/CreateCollectionOperation"
              }
            },
            "required": [
              "create_collection"
            ],
            "type": "object"
          },
          {
            "additionalProperties": false,
            "properties": {
              "update_collection": {
                "$ref": "#/components/schemas/UpdateCollectionOperation"
              }
            },
            "required": [
              "update_collection"
            ],
            "type": "object"
          },
          {
            "additionalProperties": false,
            "properties": {
              "delete_collection": {
                "$ref": "#/components/schemas/DeleteCollectionOperation"
              }
            },
            "required": [
              "delete_collection"
            ],
            "type": "object"
          },
          {
            "additionalProperties": false,
            "properties": {
              "change_aliases": {
                "$ref": "#/components/schemas/ChangeAliasesOperation"
              }
            },
            "required": [
              "change_aliases"
            ],
            "type": "object"
          }
        ]
      },
      "UpdateCollection": {
        "description": "Operation for updating parameters of the existing collection",
        "properties": {
          "optimizers_config": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/OptimizersConfigDiff"
              },
              {
                "nullable": true
              }
            ],
            "description": "Custom params for Optimizers.  If none - values from service configuration file are used. This operation is blocking, it will only proceed ones all current optimizations are complete"
          }
        },
        "type": "object"
      },
      "UpdateCollectionOperation": {
        "description": "Operation for updating parameters of the existing collection",
        "properties": {
          "collection_name": {
            "type": "string"
          },
          "optimizers_config": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/OptimizersConfigDiff"
              },
              {
                "nullable": true
              }
            ],
            "description": "Custom params for Optimizers.  If none - values from service configuration file are used. This operation is blocking, it will only proceed ones all current optimizations are complete"
          }
        },
        "required": [
          "collection_name"
        ],
        "type": "object"
      },
      "UpdateResult": {
        "properties": {
          "operation_id": {
            "description": "Sequential number of the operation",
            "format": "uint64",
            "minimum": 0,
            "type": "integer"
          },
          "status": {
            "$ref": "#/components/schemas/UpdateStatus"
          }
        },
        "required": [
          "operation_id",
          "status"
        ],
        "type": "object"
      },
      "UpdateStatus": {
        "enum": [
          "acknowledged",
          "completed"
        ],
        "type": "string"
      },
      "WalConfig": {
        "properties": {
          "wal_capacity_mb": {
            "description": "Size of a single WAL segment in MB",
            "format": "uint",
            "minimum": 0,
            "type": "integer"
          },
          "wal_segments_ahead": {
            "description": "Number of WAL segments to create ahead of actually used ones",
            "format": "uint",
            "minimum": 0,
            "type": "integer"
          }
        },
        "required": [
          "wal_capacity_mb",
          "wal_segments_ahead"
        ],
        "type": "object"
      },
      "WalConfigDiff": {
        "properties": {
          "wal_capacity_mb": {
            "description": "Size of a single WAL segment in MB",
            "format": "uint",
            "minimum": 0,
            "nullable": true,
            "type": "integer"
          },
          "wal_segments_ahead": {
            "description": "Number of WAL segments to create ahead of actually used ones",
            "format": "uint",
            "minimum": 0,
            "nullable": true,
            "type": "integer"
          }
        },
        "type": "object"
      },
      "WithPayloadInterface": {
        "anyOf": [
          {
            "description": "If `true` - return all payload, If `false` - do not return payload",
            "type": "boolean"
          },
          {
            "description": "Specify which fields to return",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          {
            "$ref": "#/components/schemas/PayloadSelector"
          }
        ],
        "description": "Options for specifying which payload to include or not"
      }
    }
  },
  "externalDocs": {
    "description": "Find out more about Qdrant aplications and demo",
    "url": "https://qdrant.tech/documentation/"
  },
  "info": {
    "contact": {
      "email": "andrey@vasnetsov.com"
    },
    "description": "API description for Qdrant vector search engine.\n\nThis document describes CRUD and search operations on collections of points (vectors with payload).\n\nQdrant supports any combinations of `should`, `must` and `must_not` conditions, which makes it possible to use in applications when object could not be described solely by vector. It could be location features, availability flags, and other custom properties businesses should take into account.\n## Examples\nThis examples cover the most basic use-cases - collection creation and basic vector search.\n### Create collection\nFirst - let's create a collection with dot-production metric.\n```\ncurl -X PUT 'http://localhost:6333/collections/test_collection' \\\n  -H 'Content-Type: application/json' \\\n  --data-raw '{\n    \"vector_size\": 4,\n    \"distance\": \"Dot\"\n  }'\n\n```\nExpected response:\n```\n{\n    \"result\": true,\n    \"status\": \"ok\",\n    \"time\": 0.031095451\n}\n```\nWe can ensure that collection was created:\n```\ncurl 'http://localhost:6333/collections/test_collection'\n```\nExpected response:\n```\n{\n  \"result\": {\n    \"status\": \"green\",\n    \"vectors_count\": 0,\n    \"segments_count\": 5,\n    \"disk_data_size\": 0,\n    \"ram_data_size\": 0,\n    \"config\": {\n      \"params\": {\n        \"vector_size\": 4,\n        \"distance\": \"Dot\"\n      },\n      \"hnsw_config\": {\n        \"m\": 16,\n        \"ef_construct\": 100,\n        \"full_scan_threshold\": 10000\n      },\n      \"optimizer_config\": {\n        \"deleted_threshold\": 0.2,\n        \"vacuum_min_vector_number\": 1000,\n        \"max_segment_number\": 5,\n        \"memmap_threshold\": 50000,\n        \"indexing_threshold\": 20000,\n        \"payload_indexing_threshold\": 10000,\n        \"flush_interval_sec\": 1\n      },\n      \"wal_config\": {\n        \"wal_capacity_mb\": 32,\n        \"wal_segments_ahead\": 0\n      }\n    }\n  },\n  \"status\": \"ok\",\n  \"time\": 2.1199e-05\n}\n```\n\n### Add points\nLet's now add vectors with some payload:\n```\ncurl -L -X PUT 'http://localhost:6333/collections/test_collection/points?wait=true' \\ -H 'Content-Type: application/json' \\ --data-raw '{\n  \"points\": [\n    {\"id\": 1, \"vector\": [0.05, 0.61, 0.76, 0.74], \"payload\": {\"city\": \"Berlin\"}},\n    {\"id\": 2, \"vector\": [0.19, 0.81, 0.75, 0.11], \"payload\": {\"city\": [\"Berlin\", \"London\"] }},\n    {\"id\": 3, \"vector\": [0.36, 0.55, 0.47, 0.94], \"payload\": {\"city\": [\"Berlin\", \"Moscow\"] }},\n    {\"id\": 4, \"vector\": [0.18, 0.01, 0.85, 0.80], \"payload\": {\"city\": [\"London\", \"Moscow\"] }},\n    {\"id\": 5, \"vector\": [0.24, 0.18, 0.22, 0.44], \"payload\": {\"count\": [0]}},\n    {\"id\": 6, \"vector\": [0.35, 0.08, 0.11, 0.44]}\n  ]\n}'\n```\nExpected response:\n```\n{\n    \"result\": {\n        \"operation_id\": 0,\n        \"status\": \"completed\"\n    },\n    \"status\": \"ok\",\n    \"time\": 0.000206061\n}\n```\n### Search with filtering\nLet's start with a basic request:\n```\ncurl -L -X POST 'http://localhost:6333/collections/test_collection/points/search' \\ -H 'Content-Type: application/json' \\ --data-raw '{\n    \"vector\": [0.2,0.1,0.9,0.7],\n    \"top\": 3\n}'\n```\nExpected response:\n```\n{\n    \"result\": [\n        { \"id\": 4, \"score\": 1.362, \"payload\": null, \"version\": 0 },\n        { \"id\": 1, \"score\": 1.273, \"payload\": null, \"version\": 0 },\n        { \"id\": 3, \"score\": 1.208, \"payload\": null, \"version\": 0 }\n    ],\n    \"status\": \"ok\",\n    \"time\": 0.000055785\n}\n```\nBut result is different if we add a filter:\n```\ncurl -L -X POST 'http://localhost:6333/collections/test_collection/points/search' \\ -H 'Content-Type: application/json' \\ --data-raw '{\n    \"filter\": {\n        \"should\": [\n            {\n                \"key\": \"city\",\n                \"match\": {\n                    \"keyword\": \"London\"\n                }\n            }\n        ]\n    },\n    \"vector\": [0.2, 0.1, 0.9, 0.7],\n    \"top\": 3\n}'\n```\nExpected response:\n```\n{\n    \"result\": [\n        { \"id\": 4, \"score\": 1.362, \"payload\": null, \"version\": 0 },\n        { \"id\": 2, \"score\": 0.871, \"payload\": null, \"version\": 0 }\n    ],\n    \"status\": \"ok\",\n    \"time\": 0.000093972\n}\n```\n",
    "license": {
      "name": "Apache 2.0",
      "url": "http://www.apache.org/licenses/LICENSE-2.0.html"
    },
    "title": "Qdrant API",
    "version": "master"
  },
  "openapi": "3.0.1",
  "paths": {
    "/collections": {
      "get": {
        "description": "Get list name of all existing collections",
        "operationId": "get_collections",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "result": {
                      "$ref": "#/components/schemas/CollectionsResponse"
                    },
                    "status": {
                      "enum": [
                        "ok"
                      ],
                      "type": "string"
                    },
                    "time": {
                      "description": "Time spent to process this request",
                      "format": "float",
                      "type": "number"
                    }
                  },
                  "type": "object"
                }
              }
            },
            "description": "successful operation"
          },
          "4XX": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "error"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "error"
          }
        },
        "summary": "List collections",
        "tags": [
          "collections"
        ]
      },
      "post": {
        "deprecated": true,
        "description": "Perform update, create, remove or alias change operations on collections",
        "operationId": "update_collections",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/StorageOperations"
              }
            }
          },
          "description": "Operation to perform on collections"
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "result": {
                      "type": "boolean"
                    },
                    "status": {
                      "enum": [
                        "ok"
                      ],
                      "type": "string"
                    },
                    "time": {
                      "description": "Time spent to process this request",
                      "format": "float",
                      "type": "number"
                    }
                  },
                  "type": "object"
                }
              }
            },
            "description": "successful operation"
          },
          "4XX": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "error"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "error"
          }
        },
        "summary": "Update collection",
        "tags": [
          "collections"
        ]
      }
    },
    "/collections/aliases": {
      "post": {
        "operationId": "update_aliases",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ChangeAliasesOperation"
              }
            }
          },
          "description": "Alias update operations"
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "result": {
                      "type": "boolean"
                    },
                    "status": {
                      "enum": [
                        "ok"
                      ],
                      "type": "string"
                    },
                    "time": {
                      "description": "Time spent to process this request",
                      "format": "float",
                      "type": "number"
                    }
                  },
                  "type": "object"
                }
              }
            },
            "description": "successful operation"
          },
          "4XX": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "error"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "error"
          }
        },
        "summary": "Update aliases of the collections",
        "tags": [
          "collections"
        ]
      }
    },
    "/collections/{collection_name}": {
      "delete": {
        "description": "Drop collection and all associated data",
        "operationId": "delete_collection",
        "parameters": [
          {
            "description": "Name of the collection to delete",
            "in": "path",
            "name": "collection_name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "result": {
                      "type": "boolean"
                    },
                    "status": {
                      "enum": [
                        "ok"
                      ],
                      "type": "string"
                    },
                    "time": {
                      "description": "Time spent to process this request",
                      "format": "float",
                      "type": "number"
                    }
                  },
                  "type": "object"
                }
              }
            },
            "description": "successful operation"
          },
          "4XX": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "error"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "error"
          }
        },
        "summary": "Delete collection",
        "tags": [
          "collections"
        ]
      },
      "get": {
        "description": "Get detailed information about specified existing collection",
        "operationId": "get_collection",
        "parameters": [
          {
            "description": "Name of the collection to retrieve",
            "in": "path",
            "name": "collection_name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "result": {
                      "$ref": "#/components/schemas/CollectionInfo"
                    },
                    "status": {
                      "enum": [
                        "ok"
                      ],
                      "type": "string"
                    },
                    "time": {
                      "description": "Time spent to process this request",
                      "format": "float",
                      "type": "number"
                    }
                  },
                  "type": "object"
                }
              }
            },
            "description": "successful operation"
          },
          "4XX": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "error"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "error"
          }
        },
        "summary": "Collection info",
        "tags": [
          "collections"
        ]
      },
      "patch": {
        "description": "Update parameters of the existing collection",
        "operationId": "update_collection",
        "parameters": [
          {
            "description": "Name of the collection to update",
            "in": "path",
            "name": "collection_name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateCollection"
              }
            }
          },
          "description": "New parameters"
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "result": {
                      "type": "boolean"
                    },
                    "status": {
                      "enum": [
                        "ok"
                      ],
                      "type": "string"
                    },
                    "time": {
                      "description": "Time spent to process this request",
                      "format": "float",
                      "type": "number"
                    }
                  },
                  "type": "object"
                }
              }
            },
            "description": "successful operation"
          },
          "4XX": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "error"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "error"
          }
        },
        "summary": "Update collection parameters",
        "tags": [
          "collections"
        ]
      },
      "post": {
        "deprecated": true,
        "description": "Perform point update operation (vectors, payloads, indexes) in collection",
        "operationId": "update_points",
        "parameters": [
          {
            "description": "Name of the collection to search in",
            "in": "path",
            "name": "collection_name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "If true, wait for changes to actually happen",
            "in": "query",
            "name": "wait",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CollectionUpdateOperations"
              }
            }
          },
          "description": "Collection update operations"
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "result": {
                      "$ref": "#/components/schemas/UpdateResult"
                    },
                    "status": {
                      "enum": [
                        "ok"
                      ],
                      "type": "string"
                    },
                    "time": {
                      "description": "Time spent to process this request",
                      "format": "float",
                      "type": "number"
                    }
                  },
                  "type": "object"
                }
              }
            },
            "description": "successful operation"
          },
          "4XX": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "error"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "error"
          }
        },
        "summary": "Update points",
        "tags": [
          "points"
        ]
      },
      "put": {
        "description": "Create new collection with given parameters",
        "operationId": "create_collection",
        "parameters": [
          {
            "description": "Name of the new collection",
            "in": "path",
            "name": "collection_name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateCollection"
              }
            }
          },
          "description": "Parameters of a new collection"
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "result": {
                      "type": "boolean"
                    },
                    "status": {
                      "enum": [
                        "ok"
                      ],
                      "type": "string"
                    },
                    "time": {
                      "description": "Time spent to process this request",
                      "format": "float",
                      "type": "number"
                    }
                  },
                  "type": "object"
                }
              }
            },
            "description": "successful operation"
          },
          "4XX": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "error"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "error"
          }
        },
        "summary": "Create collection",
        "tags": [
          "collections"
        ]
      }
    },
    "/collections/{collection_name}/index": {
      "put": {
        "description": "Create index for field in collection",
        "operationId": "create_field_index",
        "parameters": [
          {
            "description": "Name of the collection",
            "in": "path",
            "name": "collection_name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "If true, wait for changes to actually happen",
            "in": "query",
            "name": "wait",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateFieldIndex"
              }
            }
          },
          "description": "Field name"
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "result": {
                      "$ref": "#/components/schemas/UpdateResult"
                    },
                    "status": {
                      "enum": [
                        "ok"
                      ],
                      "type": "string"
                    },
                    "time": {
                      "description": "Time spent to process this request",
                      "format": "float",
                      "type": "number"
                    }
                  },
                  "type": "object"
                }
              }
            },
            "description": "successful operation"
          },
          "4XX": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "error"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "error"
          }
        },
        "summary": "Create index for field in collection",
        "tags": [
          "collections"
        ]
      }
    },
    "/collections/{collection_name}/index/{field_name}": {
      "delete": {
        "description": "Delete field index for collection",
        "operationId": "delete_field_index",
        "parameters": [
          {
            "description": "Name of the collection",
            "in": "path",
            "name": "collection_name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Name of the field where to delete the index",
            "in": "path",
            "name": "field_name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "If true, wait for changes to actually happen",
            "in": "query",
            "name": "wait",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "result": {
                      "$ref": "#/components/schemas/UpdateResult"
                    },
                    "status": {
                      "enum": [
                        "ok"
                      ],
                      "type": "string"
                    },
                    "time": {
                      "description": "Time spent to process this request",
                      "format": "float",
                      "type": "number"
                    }
                  },
                  "type": "object"
                }
              }
            },
            "description": "successful operation"
          },
          "4XX": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "error"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "error"
          }
        },
        "summary": "Delete index for field in collection",
        "tags": [
          "collections"
        ]
      }
    },
    "/collections/{collection_name}/points": {
      "post": {
        "description": "Retrieve multiple points by specified IDs",
        "operationId": "get_points",
        "parameters": [
          {
            "description": "Name of the collection to retrieve from",
            "in": "path",
            "name": "collection_name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PointRequest"
              }
            }
          },
          "description": "List of points to retrieve"
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "result": {
                      "items": {
                        "$ref": "#/components/schemas/Record"
                      },
                      "type": "array"
                    },
                    "status": {
                      "enum": [
                        "ok"
                      ],
                      "type": "string"
                    },
                    "time": {
                      "description": "Time spent to process this request",
                      "format": "float",
                      "type": "number"
                    }
                  },
                  "type": "object"
                }
              }
            },
            "description": "successful operation"
          },
          "4XX": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "error"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "error"
          }
        },
        "summary": "Get points",
        "tags": [
          "points"
        ]
      },
      "put": {
        "description": "Perform insert + updates on points. If point with given ID already exists - it will be overwritten.",
        "operationId": "upsert_points",
        "parameters": [
          {
            "description": "Name of the collection to update from",
            "in": "path",
            "name": "collection_name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "If true, wait for changes to actually happen",
            "in": "query",
            "name": "wait",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PointInsertOperations"
              }
            }
          },
          "description": "Operation to perform on points"
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "result": {
                      "$ref": "#/components/schemas/UpdateResult"
                    },
                    "status": {
                      "enum": [
                        "ok"
                      ],
                      "type": "string"
                    },
                    "time": {
                      "description": "Time spent to process this request",
                      "format": "float",
                      "type": "number"
                    }
                  },
                  "type": "object"
                }
              }
            },
            "description": "successful operation"
          },
          "4XX": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "error"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "error"
          }
        },
        "summary": "Upsert points",
        "tags": [
          "points"
        ]
      }
    },
    "/collections/{collection_name}/points/delete": {
      "post": {
        "description": "Delete points",
        "operationId": "delete_points",
        "parameters": [
          {
            "description": "Name of the collection to delete from",
            "in": "path",
            "name": "collection_name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "If true, wait for changes to actually happen",
            "in": "query",
            "name": "wait",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PointsSelector"
              }
            }
          },
          "description": "Operation to perform on points"
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "result": {
                      "$ref": "#/components/schemas/UpdateResult"
                    },
                    "status": {
                      "enum": [
                        "ok"
                      ],
                      "type": "string"
                    },
                    "time": {
                      "description": "Time spent to process this request",
                      "format": "float",
                      "type": "number"
                    }
                  },
                  "type": "object"
                }
              }
            },
            "description": "successful operation"
          },
          "4XX": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "error"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "error"
          }
        },
        "summary": "Delete points",
        "tags": [
          "points"
        ]
      }
    },
    "/collections/{collection_name}/points/payload": {
      "post": {
        "description": "Set payload for points",
        "operationId": "set_payload",
        "parameters": [
          {
            "description": "Name of the collection to set from",
            "in": "path",
            "name": "collection_name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "If true, wait for changes to actually happen",
            "in": "query",
            "name": "wait",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SetPayload"
              }
            }
          },
          "description": "Set payload on points"
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "result": {
                      "$ref": "#/components/schemas/UpdateResult"
                    },
                    "status": {
                      "enum": [
                        "ok"
                      ],
                      "type": "string"
                    },
                    "time": {
                      "description": "Time spent to process this request",
                      "format": "float",
                      "type": "number"
                    }
                  },
                  "type": "object"
                }
              }
            },
            "description": "successful operation"
          },
          "4XX": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "error"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "error"
          }
        },
        "summary": "Set payload",
        "tags": [
          "points"
        ]
      }
    },
    "/collections/{collection_name}/points/payload/clear": {
      "post": {
        "description": "Remove all payload for specified points",
        "operationId": "clear_payload",
        "parameters": [
          {
            "description": "Name of the collection to clear payload from",
            "in": "path",
            "name": "collection_name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "If true, wait for changes to actually happen",
            "in": "query",
            "name": "wait",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PointsSelector"
              }
            }
          },
          "description": "clear payload on points"
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "result": {
                      "$ref": "#/components/schemas/UpdateResult"
                    },
                    "status": {
                      "enum": [
                        "ok"
                      ],
                      "type": "string"
                    },
                    "time": {
                      "description": "Time spent to process this request",
                      "format": "float",
                      "type": "number"
                    }
                  },
                  "type": "object"
                }
              }
            },
            "description": "successful operation"
          },
          "4XX": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "error"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "error"
          }
        },
        "summary": "Clear payload",
        "tags": [
          "points"
        ]
      }
    },
    "/collections/{collection_name}/points/payload/delete": {
      "post": {
        "description": "Delete specified key payload for points",
        "operationId": "delete_payload",
        "parameters": [
          {
            "description": "Name of the collection to delete from",
            "in": "path",
            "name": "collection_name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "If true, wait for changes to actually happen",
            "in": "query",
            "name": "wait",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeletePayload"
              }
            }
          },
          "description": "delete payload on points"
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "result": {
                      "$ref": "#/components/schemas/UpdateResult"
                    },
                    "status": {
                      "enum": [
                        "ok"
                      ],
                      "type": "string"
                    },
                    "time": {
                      "description": "Time spent to process this request",
                      "format": "float",
                      "type": "number"
                    }
                  },
                  "type": "object"
                }
              }
            },
            "description": "successful operation"
          },
          "4XX": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "error"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "error"
          }
        },
        "summary": "Delete payload",
        "tags": [
          "points"
        ]
      }
    },
    "/collections/{collection_name}/points/recommend": {
      "post": {
        "description": "Look for the points which are closer to stored positive examples and at the same time further to negative examples.",
        "operationId": "recommend_points",
        "parameters": [
          {
            "description": "Name of the collection to search in",
            "in": "path",
            "name": "collection_name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RecommendRequest"
              }
            }
          },
          "description": "Request points based on positive and negative examples."
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "result": {
                      "items": {
                        "$ref": "#/components/schemas/ScoredPoint"
                      },
                      "type": "array"
                    },
                    "status": {
                      "enum": [
                        "ok"
                      ],
                      "type": "string"
                    },
                    "time": {
                      "description": "Time spent to process this request",
                      "format": "float",
                      "type": "number"
                    }
                  },
                  "type": "object"
                }
              }
            },
            "description": "successful operation"
          },
          "4XX": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "error"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "error"
          }
        },
        "summary": "Recommend points",
        "tags": [
          "points"
        ]
      }
    },
    "/collections/{collection_name}/points/scroll": {
      "post": {
        "description": "Scroll request - paginate over all points which matches given filtering condition",
        "operationId": "scroll_points",
        "parameters": [
          {
            "description": "Name of the collection to retrieve from",
            "in": "path",
            "name": "collection_name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ScrollRequest"
              }
            }
          },
          "description": "Pagination and filter parameters"
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "result": {
                      "$ref": "#/components/schemas/ScrollResult"
                    },
                    "status": {
                      "enum": [
                        "ok"
                      ],
                      "type": "string"
                    },
                    "time": {
                      "description": "Time spent to process this request",
                      "format": "float",
                      "type": "number"
                    }
                  },
                  "type": "object"
                }
              }
            },
            "description": "successful operation"
          },
          "4XX": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "error"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "error"
          }
        },
        "summary": "Scroll points",
        "tags": [
          "points"
        ]
      }
    },
    "/collections/{collection_name}/points/search": {
      "post": {
        "description": "Retrieve closest points based on vector similarity and given filtering conditions",
        "operationId": "search_points",
        "parameters": [
          {
            "description": "Name of the collection to search in",
            "in": "path",
            "name": "collection_name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SearchRequest"
              }
            }
          },
          "description": "Search request with optional filtering"
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "result": {
                      "items": {
                        "$ref": "#/components/schemas/ScoredPoint"
                      },
                      "type": "array"
                    },
                    "status": {
                      "enum": [
                        "ok"
                      ],
                      "type": "string"
                    },
                    "time": {
                      "description": "Time spent to process this request",
                      "format": "float",
                      "type": "number"
                    }
                  },
                  "type": "object"
                }
              }
            },
            "description": "successful operation"
          },
          "4XX": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "error"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "error"
          }
        },
        "summary": "Search points",
        "tags": [
          "points"
        ]
      }
    },
    "/collections/{collection_name}/points/{id}": {
      "get": {
        "description": "Retrieve full information of single point by id",
        "operationId": "get_point",
        "parameters": [
          {
            "description": "Name of the collection to retrieve from",
            "in": "path",
            "name": "collection_name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Id of the point",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/ExtendedPointId"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "result": {
                      "$ref": "#/components/schemas/Record"
                    },
                    "status": {
                      "enum": [
                        "ok"
                      ],
                      "type": "string"
                    },
                    "time": {
                      "description": "Time spent to process this request",
                      "format": "float",
                      "type": "number"
                    }
                  },
                  "type": "object"
                }
              }
            },
            "description": "successful operation"
          },
          "4XX": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "error"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "error"
          }
        },
        "summary": "Get point",
        "tags": [
          "points"
        ]
      }
    }
  },
  "servers": [
    {
      "url": "http://localhost:6333"
    }
  ],
  "tags": [
    {
      "description": "Searchable collections of points.",
      "name": "collections"
    },
    {
      "description": "Float-point vectors with payload.",
      "name": "points"
    }
  ]
}

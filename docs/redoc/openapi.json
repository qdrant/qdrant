{
  "components": {
    "schemas": {
      "AliasOperations": {
        "anyOf": [
          {
            "additionalProperties": false,
            "description": "Create alternative name for a collection. Collection will be available under both names for search, retrieve,",
            "properties": {
              "create_alias": {
                "properties": {
                  "alias_name": {
                    "type": "string"
                  },
                  "collection_name": {
                    "type": "string"
                  }
                },
                "required": [
                  "alias_name",
                  "collection_name"
                ],
                "type": "object"
              }
            },
            "required": [
              "create_alias"
            ],
            "type": "object"
          },
          {
            "additionalProperties": false,
            "description": "Delete alias if exists",
            "properties": {
              "delete_alias": {
                "properties": {
                  "alias_name": {
                    "type": "string"
                  }
                },
                "required": [
                  "alias_name"
                ],
                "type": "object"
              }
            },
            "required": [
              "delete_alias"
            ],
            "type": "object"
          },
          {
            "additionalProperties": false,
            "description": "Change alias to a new one",
            "properties": {
              "rename_alias": {
                "properties": {
                  "new_alias_name": {
                    "type": "string"
                  },
                  "old_alias_name": {
                    "type": "string"
                  }
                },
                "required": [
                  "new_alias_name",
                  "old_alias_name"
                ],
                "type": "object"
              }
            },
            "required": [
              "rename_alias"
            ],
            "type": "object"
          }
        ]
      },
      "CollectionConfig": {
        "properties": {
          "hnsw_config": {
            "$ref": "#/components/schemas/HnswConfig"
          },
          "optimizer_config": {
            "$ref": "#/components/schemas/OptimizersConfig"
          },
          "params": {
            "$ref": "#/components/schemas/CollectionParams"
          },
          "wal_config": {
            "$ref": "#/components/schemas/WalConfig"
          }
        },
        "required": [
          "hnsw_config",
          "optimizer_config",
          "params",
          "wal_config"
        ],
        "type": "object"
      },
      "CollectionDescription": {
        "properties": {
          "name": {
            "type": "string"
          }
        },
        "required": [
          "name"
        ],
        "type": "object"
      },
      "CollectionInfo": {
        "description": "Current statistics and configuration of the collection.",
        "properties": {
          "config": {
            "$ref": "#/components/schemas/CollectionConfig"
          },
          "disk_data_size": {
            "description": "Disk space, used by collection",
            "format": "uint",
            "minimum": 0,
            "type": "integer"
          },
          "payload_schema": {
            "additionalProperties": {
              "$ref": "#/components/schemas/PayloadSchemaInfo"
            },
            "description": "Types of stored payload",
            "type": "object"
          },
          "ram_data_size": {
            "description": "RAM used by collection",
            "format": "uint",
            "minimum": 0,
            "type": "integer"
          },
          "segments_count": {
            "description": "Number of segments in collection",
            "format": "uint",
            "minimum": 0,
            "type": "integer"
          },
          "status": {
            "$ref": "#/components/schemas/CollectionStatus"
          },
          "vectors_count": {
            "description": "Number of vectors in collection",
            "format": "uint",
            "minimum": 0,
            "type": "integer"
          }
        },
        "required": [
          "config",
          "disk_data_size",
          "payload_schema",
          "ram_data_size",
          "segments_count",
          "status",
          "vectors_count"
        ],
        "type": "object"
      },
      "CollectionParams": {
        "properties": {
          "distance": {
            "$ref": "#/components/schemas/Distance"
          },
          "vector_size": {
            "description": "Size of a vectors used",
            "format": "uint",
            "minimum": 0,
            "type": "integer"
          }
        },
        "required": [
          "distance",
          "vector_size"
        ],
        "type": "object"
      },
      "CollectionStatus": {
        "enum": [
          "green",
          "yellow",
          "red"
        ],
        "type": "string"
      },
      "CollectionUpdateOperations": {
        "anyOf": [
          {
            "$ref": "#/components/schemas/PointOperations"
          },
          {
            "$ref": "#/components/schemas/PayloadOps"
          },
          {
            "$ref": "#/components/schemas/FieldIndexOperations"
          }
        ]
      },
      "CollectionsResponse": {
        "properties": {
          "collections": {
            "items": {
              "$ref": "#/components/schemas/CollectionDescription"
            },
            "type": "array"
          }
        },
        "required": [
          "collections"
        ],
        "type": "object"
      },
      "Condition": {
        "anyOf": [
          {
            "$ref": "#/components/schemas/FieldCondition"
          },
          {
            "$ref": "#/components/schemas/HasIdCondition"
          },
          {
            "$ref": "#/components/schemas/Filter"
          }
        ]
      },
      "Distance": {
        "description": "Type of internal tags, build from payload Distance function types used to compare vectors",
        "enum": [
          "Cosine",
          "Euclid",
          "Dot"
        ],
        "type": "string"
      },
      "ErrorResponse": {
        "properties": {
          "result": {
            "nullable": true,
            "type": "object"
          },
          "status": {
            "properties": {
              "error": {
                "description": "Description of the occurred error.",
                "type": "string"
              }
            },
            "type": "object"
          },
          "time": {
            "description": "Time spent to process this request",
            "format": "float",
            "type": "number"
          }
        },
        "type": "object"
      },
      "FieldCondition": {
        "properties": {
          "geo_bounding_box": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/GeoBoundingBox"
              },
              {
                "nullable": true
              }
            ],
            "description": "Check if points geo location lies in a given area"
          },
          "geo_radius": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/GeoRadius"
              },
              {
                "nullable": true
              }
            ],
            "description": "Check if geo point is within a given radius"
          },
          "key": {
            "type": "string"
          },
          "match": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/Match"
              },
              {
                "nullable": true
              }
            ],
            "description": "Check if point has field with a given value"
          },
          "range": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/Range"
              },
              {
                "nullable": true
              }
            ],
            "description": "Check if points value lies in a given range"
          }
        },
        "required": [
          "key"
        ],
        "type": "object"
      },
      "FieldIndexOperations": {
        "anyOf": [
          {
            "additionalProperties": false,
            "description": "Create index for payload field",
            "properties": {
              "create_index": {
                "type": "string"
              }
            },
            "required": [
              "create_index"
            ],
            "type": "object"
          },
          {
            "additionalProperties": false,
            "description": "Delete index for the field",
            "properties": {
              "delete_index": {
                "type": "string"
              }
            },
            "required": [
              "delete_index"
            ],
            "type": "object"
          }
        ]
      },
      "Filter": {
        "additionalProperties": false,
        "properties": {
          "must": {
            "description": "All conditions must match",
            "items": {
              "$ref": "#/components/schemas/Condition"
            },
            "nullable": true,
            "type": "array"
          },
          "must_not": {
            "description": "All conditions must NOT match",
            "items": {
              "$ref": "#/components/schemas/Condition"
            },
            "nullable": true,
            "type": "array"
          },
          "should": {
            "description": "At least one of thous conditions should match",
            "items": {
              "$ref": "#/components/schemas/Condition"
            },
            "nullable": true,
            "type": "array"
          }
        },
        "type": "object"
      },
      "GeoBoundingBox": {
        "properties": {
          "bottom_right": {
            "$ref": "#/components/schemas/GeoPoint"
          },
          "top_left": {
            "$ref": "#/components/schemas/GeoPoint"
          }
        },
        "required": [
          "bottom_right",
          "top_left"
        ],
        "type": "object"
      },
      "GeoPoint": {
        "properties": {
          "lat": {
            "format": "double",
            "type": "number"
          },
          "lon": {
            "format": "double",
            "type": "number"
          }
        },
        "required": [
          "lat",
          "lon"
        ],
        "type": "object"
      },
      "GeoRadius": {
        "properties": {
          "center": {
            "$ref": "#/components/schemas/GeoPoint"
          },
          "radius": {
            "description": "Radius of the area in meters",
            "format": "double",
            "type": "number"
          }
        },
        "required": [
          "center",
          "radius"
        ],
        "type": "object"
      },
      "HasIdCondition": {
        "properties": {
          "has_id": {
            "items": {
              "format": "uint64",
              "minimum": 0,
              "type": "integer"
            },
            "type": "array",
            "uniqueItems": true
          }
        },
        "required": [
          "has_id"
        ],
        "type": "object"
      },
      "HnswConfig": {
        "properties": {
          "ef_construct": {
            "description": "Number of neighbours to consider during the index building. Larger the value - more accurate the search, more time required to build index.",
            "format": "uint",
            "minimum": 0,
            "type": "integer"
          },
          "full_scan_threshold": {
            "description": "Minimal amount of points for additional payload-based indexing. If payload chunk is smaller than `full_scan_threshold` additional indexing won't be used - in this case full-scan search should be preferred by query planner and additional indexing is not required.",
            "format": "uint",
            "minimum": 0,
            "type": "integer"
          },
          "m": {
            "description": "Number of edges per node in the index graph. Larger the value - more accurate the search, more space required.",
            "format": "uint",
            "minimum": 0,
            "type": "integer"
          }
        },
        "required": [
          "ef_construct",
          "full_scan_threshold",
          "m"
        ],
        "type": "object"
      },
      "HnswConfigDiff": {
        "properties": {
          "ef_construct": {
            "description": "Number of neighbours to consider during the index building. Larger the value - more accurate the search, more time required to build index.",
            "format": "uint",
            "minimum": 0,
            "nullable": true,
            "type": "integer"
          },
          "full_scan_threshold": {
            "description": "Minimal amount of points for additional payload-based indexing. If payload chunk is smaller than `full_scan_threshold` additional indexing won't be used - in this case full-scan search should be preferred by query planner and additional indexing is not required.",
            "format": "uint",
            "minimum": 0,
            "nullable": true,
            "type": "integer"
          },
          "m": {
            "description": "Number of edges per node in the index graph. Larger the value - more accurate the search, more space required.",
            "format": "uint",
            "minimum": 0,
            "nullable": true,
            "type": "integer"
          }
        },
        "type": "object"
      },
      "Match": {
        "properties": {
          "integer": {
            "description": "Integer value to match",
            "format": "int64",
            "nullable": true,
            "type": "integer"
          },
          "keyword": {
            "description": "Keyword value to match",
            "nullable": true,
            "type": "string"
          }
        },
        "type": "object"
      },
      "OptimizersConfig": {
        "properties": {
          "deleted_threshold": {
            "description": "The minimal fraction of deleted vectors in a segment, required to perform segment optimization",
            "format": "double",
            "type": "number"
          },
          "flush_interval_sec": {
            "description": "Minimum interval between forced flushes.",
            "format": "uint64",
            "minimum": 0,
            "type": "integer"
          },
          "indexing_threshold": {
            "description": "Maximum number of vectors allowed for plain index. Default value based on https://github.com/google-research/google-research/blob/master/scann/docs/algorithms.md",
            "format": "uint",
            "minimum": 0,
            "type": "integer"
          },
          "max_segment_number": {
            "description": "If the number of segments exceeds this value, the optimizer will merge the smallest segments.",
            "format": "uint",
            "minimum": 0,
            "type": "integer"
          },
          "memmap_threshold": {
            "description": "Maximum number of vectors to store in-memory per segment. Segments larger than this threshold will be stored as read-only memmaped file.",
            "format": "uint",
            "minimum": 0,
            "type": "integer"
          },
          "payload_indexing_threshold": {
            "description": "Starting from this amount of vectors per-segment the engine will start building index for payload.",
            "format": "uint",
            "minimum": 0,
            "type": "integer"
          },
          "vacuum_min_vector_number": {
            "description": "The minimal number of vectors in a segment, required to perform segment optimization",
            "format": "uint",
            "minimum": 0,
            "type": "integer"
          }
        },
        "required": [
          "deleted_threshold",
          "flush_interval_sec",
          "indexing_threshold",
          "max_segment_number",
          "memmap_threshold",
          "payload_indexing_threshold",
          "vacuum_min_vector_number"
        ],
        "type": "object"
      },
      "OptimizersConfigDiff": {
        "properties": {
          "deleted_threshold": {
            "description": "The minimal fraction of deleted vectors in a segment, required to perform segment optimization",
            "format": "double",
            "nullable": true,
            "type": "number"
          },
          "flush_interval_sec": {
            "description": "Minimum interval between forced flushes.",
            "format": "uint64",
            "minimum": 0,
            "nullable": true,
            "type": "integer"
          },
          "indexing_threshold": {
            "description": "Maximum number of vectors allowed for plain index. Default value based on https://github.com/google-research/google-research/blob/master/scann/docs/algorithms.md",
            "format": "uint",
            "minimum": 0,
            "nullable": true,
            "type": "integer"
          },
          "max_segment_number": {
            "description": "If the number of segments exceeds this value, the optimizer will merge the smallest segments.",
            "format": "uint",
            "minimum": 0,
            "nullable": true,
            "type": "integer"
          },
          "memmap_threshold": {
            "description": "Maximum number of vectors to store in-memory per segment. Segments larger than this threshold will be stored as read-only memmaped file.",
            "format": "uint",
            "minimum": 0,
            "nullable": true,
            "type": "integer"
          },
          "payload_indexing_threshold": {
            "description": "Starting from this amount of vectors per-segment the engine will start building index for payload.",
            "format": "uint",
            "minimum": 0,
            "nullable": true,
            "type": "integer"
          },
          "vacuum_min_vector_number": {
            "description": "The minimal number of vectors in a segment, required to perform segment optimization",
            "format": "uint",
            "minimum": 0,
            "nullable": true,
            "type": "integer"
          }
        },
        "type": "object"
      },
      "PayloadInterface": {
        "anyOf": [
          {
            "$ref": "#/components/schemas/PayloadVariant_for_String"
          },
          {
            "$ref": "#/components/schemas/PayloadVariant_for_int64"
          },
          {
            "$ref": "#/components/schemas/PayloadVariant_for_double"
          },
          {
            "$ref": "#/components/schemas/PayloadInterfaceStrict"
          }
        ]
      },
      "PayloadInterfaceStrict": {
        "anyOf": [
          {
            "properties": {
              "type": {
                "enum": [
                  "keyword"
                ],
                "type": "string"
              },
              "value": {
                "$ref": "#/components/schemas/PayloadVariant_for_String"
              }
            },
            "required": [
              "type",
              "value"
            ],
            "type": "object"
          },
          {
            "properties": {
              "type": {
                "enum": [
                  "integer"
                ],
                "type": "string"
              },
              "value": {
                "$ref": "#/components/schemas/PayloadVariant_for_int64"
              }
            },
            "required": [
              "type",
              "value"
            ],
            "type": "object"
          },
          {
            "properties": {
              "type": {
                "enum": [
                  "float"
                ],
                "type": "string"
              },
              "value": {
                "$ref": "#/components/schemas/PayloadVariant_for_double"
              }
            },
            "required": [
              "type",
              "value"
            ],
            "type": "object"
          },
          {
            "properties": {
              "type": {
                "enum": [
                  "geo"
                ],
                "type": "string"
              },
              "value": {
                "$ref": "#/components/schemas/PayloadVariant_for_GeoPoint"
              }
            },
            "required": [
              "type",
              "value"
            ],
            "type": "object"
          }
        ]
      },
      "PayloadOps": {
        "anyOf": [
          {
            "additionalProperties": false,
            "description": "Set payload value, overrides if it is already exists",
            "properties": {
              "set_payload": {
                "properties": {
                  "payload": {
                    "additionalProperties": {
                      "$ref": "#/components/schemas/PayloadInterface"
                    },
                    "type": "object"
                  },
                  "points": {
                    "description": "Assigns payload to each point in this list",
                    "items": {
                      "format": "uint64",
                      "minimum": 0,
                      "type": "integer"
                    },
                    "type": "array"
                  }
                },
                "required": [
                  "payload",
                  "points"
                ],
                "type": "object"
              }
            },
            "required": [
              "set_payload"
            ],
            "type": "object"
          },
          {
            "additionalProperties": false,
            "description": "Deletes specified payload values if they are assigned",
            "properties": {
              "delete_payload": {
                "properties": {
                  "keys": {
                    "items": {
                      "type": "string"
                    },
                    "type": "array"
                  },
                  "points": {
                    "description": "Deletes values from each point in this list",
                    "items": {
                      "format": "uint64",
                      "minimum": 0,
                      "type": "integer"
                    },
                    "type": "array"
                  }
                },
                "required": [
                  "keys",
                  "points"
                ],
                "type": "object"
              }
            },
            "required": [
              "delete_payload"
            ],
            "type": "object"
          },
          {
            "additionalProperties": false,
            "description": "Drops all Payload values associated with given points.",
            "properties": {
              "clear_payload": {
                "properties": {
                  "points": {
                    "items": {
                      "format": "uint64",
                      "minimum": 0,
                      "type": "integer"
                    },
                    "type": "array"
                  }
                },
                "required": [
                  "points"
                ],
                "type": "object"
              }
            },
            "required": [
              "clear_payload"
            ],
            "type": "object"
          }
        ],
        "description": "Define operations description for point payloads manipulation"
      },
      "PayloadSchemaInfo": {
        "properties": {
          "data_type": {
            "$ref": "#/components/schemas/PayloadSchemaType"
          },
          "indexed": {
            "type": "boolean"
          }
        },
        "required": [
          "data_type",
          "indexed"
        ],
        "type": "object"
      },
      "PayloadSchemaType": {
        "anyOf": [
          {
            "properties": {
              "type": {
                "enum": [
                  "keyword"
                ],
                "type": "string"
              }
            },
            "required": [
              "type"
            ],
            "type": "object"
          },
          {
            "properties": {
              "type": {
                "enum": [
                  "integer"
                ],
                "type": "string"
              }
            },
            "required": [
              "type"
            ],
            "type": "object"
          },
          {
            "properties": {
              "type": {
                "enum": [
                  "float"
                ],
                "type": "string"
              }
            },
            "required": [
              "type"
            ],
            "type": "object"
          },
          {
            "properties": {
              "type": {
                "enum": [
                  "geo"
                ],
                "type": "string"
              }
            },
            "required": [
              "type"
            ],
            "type": "object"
          }
        ]
      },
      "PayloadType": {
        "anyOf": [
          {
            "properties": {
              "type": {
                "enum": [
                  "keyword"
                ],
                "type": "string"
              },
              "value": {
                "items": {
                  "type": "string"
                },
                "type": "array"
              }
            },
            "required": [
              "type",
              "value"
            ],
            "type": "object"
          },
          {
            "properties": {
              "type": {
                "enum": [
                  "integer"
                ],
                "type": "string"
              },
              "value": {
                "items": {
                  "format": "int64",
                  "type": "integer"
                },
                "type": "array"
              }
            },
            "required": [
              "type",
              "value"
            ],
            "type": "object"
          },
          {
            "properties": {
              "type": {
                "enum": [
                  "float"
                ],
                "type": "string"
              },
              "value": {
                "items": {
                  "format": "double",
                  "type": "number"
                },
                "type": "array"
              }
            },
            "required": [
              "type",
              "value"
            ],
            "type": "object"
          },
          {
            "properties": {
              "type": {
                "enum": [
                  "geo"
                ],
                "type": "string"
              },
              "value": {
                "items": {
                  "$ref": "#/components/schemas/GeoPoint"
                },
                "type": "array"
              }
            },
            "required": [
              "type",
              "value"
            ],
            "type": "object"
          }
        ]
      },
      "PayloadVariant_for_GeoPoint": {
        "anyOf": [
          {
            "$ref": "#/components/schemas/GeoPoint"
          },
          {
            "items": {
              "$ref": "#/components/schemas/GeoPoint"
            },
            "type": "array"
          }
        ]
      },
      "PayloadVariant_for_String": {
        "anyOf": [
          {
            "type": "string"
          },
          {
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        ]
      },
      "PayloadVariant_for_double": {
        "anyOf": [
          {
            "format": "double",
            "type": "number"
          },
          {
            "items": {
              "format": "double",
              "type": "number"
            },
            "type": "array"
          }
        ]
      },
      "PayloadVariant_for_int64": {
        "anyOf": [
          {
            "format": "int64",
            "type": "integer"
          },
          {
            "items": {
              "format": "int64",
              "type": "integer"
            },
            "type": "array"
          }
        ]
      },
      "PointInsertOperations": {
        "anyOf": [
          {
            "additionalProperties": false,
            "description": "Inset points from a batch.",
            "properties": {
              "batch": {
                "properties": {
                  "ids": {
                    "items": {
                      "format": "uint64",
                      "minimum": 0,
                      "type": "integer"
                    },
                    "type": "array"
                  },
                  "payloads": {
                    "items": {
                      "additionalProperties": {
                        "$ref": "#/components/schemas/PayloadInterface"
                      },
                      "nullable": true,
                      "type": "object"
                    },
                    "nullable": true,
                    "type": "array"
                  },
                  "vectors": {
                    "items": {
                      "items": {
                        "format": "float",
                        "type": "number"
                      },
                      "type": "array"
                    },
                    "type": "array"
                  }
                },
                "required": [
                  "ids",
                  "vectors"
                ],
                "type": "object"
              }
            },
            "required": [
              "batch"
            ],
            "type": "object"
          },
          {
            "additionalProperties": false,
            "description": "Insert points from a list",
            "properties": {
              "points": {
                "items": {
                  "$ref": "#/components/schemas/PointStruct"
                },
                "type": "array"
              }
            },
            "required": [
              "points"
            ],
            "type": "object"
          }
        ]
      },
      "PointOperations": {
        "anyOf": [
          {
            "additionalProperties": false,
            "description": "Insert or update points",
            "properties": {
              "upsert_points": {
                "$ref": "#/components/schemas/PointInsertOperations"
              }
            },
            "required": [
              "upsert_points"
            ],
            "type": "object"
          },
          {
            "additionalProperties": false,
            "description": "Delete point if exists",
            "properties": {
              "delete_points": {
                "properties": {
                  "ids": {
                    "items": {
                      "format": "uint64",
                      "minimum": 0,
                      "type": "integer"
                    },
                    "type": "array"
                  }
                },
                "required": [
                  "ids"
                ],
                "type": "object"
              }
            },
            "required": [
              "delete_points"
            ],
            "type": "object"
          }
        ]
      },
      "PointRequest": {
        "properties": {
          "ids": {
            "items": {
              "format": "uint64",
              "minimum": 0,
              "type": "integer"
            },
            "type": "array"
          }
        },
        "required": [
          "ids"
        ],
        "type": "object"
      },
      "PointStruct": {
        "properties": {
          "id": {
            "description": "Point id",
            "format": "uint64",
            "minimum": 0,
            "type": "integer"
          },
          "payload": {
            "additionalProperties": {
              "$ref": "#/components/schemas/PayloadInterface"
            },
            "description": "Payload values (optional)",
            "nullable": true,
            "type": "object"
          },
          "vector": {
            "description": "Vector",
            "items": {
              "format": "float",
              "type": "number"
            },
            "type": "array"
          }
        },
        "required": [
          "id",
          "vector"
        ],
        "type": "object"
      },
      "Range": {
        "properties": {
          "gt": {
            "description": "point.key > range.gt",
            "format": "double",
            "nullable": true,
            "type": "number"
          },
          "gte": {
            "description": "point.key >= range.gte",
            "format": "double",
            "nullable": true,
            "type": "number"
          },
          "lt": {
            "description": "point.key < range.lt",
            "format": "double",
            "nullable": true,
            "type": "number"
          },
          "lte": {
            "description": "point.key <= range.lte",
            "format": "double",
            "nullable": true,
            "type": "number"
          }
        },
        "type": "object"
      },
      "RecommendRequest": {
        "description": "Search request",
        "properties": {
          "filter": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/Filter"
              },
              {
                "nullable": true
              }
            ],
            "description": "Look only for points which satisfies this conditions"
          },
          "negative": {
            "description": "Try to avoid vectors like this",
            "items": {
              "format": "uint64",
              "minimum": 0,
              "type": "integer"
            },
            "type": "array"
          },
          "params": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SearchParams"
              },
              {
                "nullable": true
              }
            ],
            "description": "Additional search params"
          },
          "positive": {
            "description": "Look for vectors closest to those",
            "items": {
              "format": "uint64",
              "minimum": 0,
              "type": "integer"
            },
            "type": "array"
          },
          "top": {
            "description": "Max number of result to return",
            "format": "uint",
            "minimum": 0,
            "type": "integer"
          }
        },
        "required": [
          "negative",
          "positive",
          "top"
        ],
        "type": "object"
      },
      "Record": {
        "description": "Point data",
        "properties": {
          "id": {
            "description": "Id of the point",
            "format": "uint64",
            "minimum": 0,
            "type": "integer"
          },
          "payload": {
            "additionalProperties": {
              "$ref": "#/components/schemas/PayloadType"
            },
            "description": "Payload - values assigned to the point",
            "nullable": true,
            "type": "object"
          },
          "vector": {
            "description": "Vector of the point",
            "items": {
              "format": "float",
              "type": "number"
            },
            "nullable": true,
            "type": "array"
          }
        },
        "required": [
          "id"
        ],
        "type": "object"
      },
      "ScoredPoint": {
        "properties": {
          "id": {
            "description": "Point id",
            "format": "uint64",
            "minimum": 0,
            "type": "integer"
          },
          "score": {
            "description": "Points vector distance to the query vector",
            "format": "float",
            "type": "number"
          }
        },
        "required": [
          "id",
          "score"
        ],
        "type": "object"
      },
      "ScrollRequest": {
        "description": "Scroll request - paginate over all points which matches given condition",
        "properties": {
          "filter": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/Filter"
              },
              {
                "nullable": true
              }
            ],
            "description": "Look only for points which satisfies this conditions. If not provided - all points."
          },
          "limit": {
            "description": "Page size. Default: 10",
            "format": "uint",
            "minimum": 0,
            "nullable": true,
            "type": "integer"
          },
          "offset": {
            "description": "Start ID to read points from. Default: 0",
            "format": "uint64",
            "minimum": 0,
            "nullable": true,
            "type": "integer"
          },
          "with_payload": {
            "description": "Return point payload with the result. Default: true",
            "nullable": true,
            "type": "boolean"
          },
          "with_vector": {
            "description": "Return point vector with the result. Default: false",
            "nullable": true,
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "ScrollResult": {
        "description": "Result of the points read request. Contains",
        "properties": {
          "next_page_offset": {
            "description": "Offset which should be used to retrieve a next page result",
            "format": "uint64",
            "minimum": 0,
            "nullable": true,
            "type": "integer"
          },
          "points": {
            "description": "List of retrieved points",
            "items": {
              "$ref": "#/components/schemas/Record"
            },
            "type": "array"
          }
        },
        "required": [
          "points"
        ],
        "type": "object"
      },
      "SearchParams": {
        "description": "Additional parameters of the search",
        "properties": {
          "hnsw_ef": {
            "description": "Params relevant to HNSW index /// Size of the beam in a beam-search. Larger the value - more accurate the result, more time required for search.",
            "format": "uint",
            "minimum": 0,
            "nullable": true,
            "type": "integer"
          }
        },
        "type": "object"
      },
      "SearchRequest": {
        "description": "Search request",
        "properties": {
          "filter": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/Filter"
              },
              {
                "nullable": true
              }
            ],
            "description": "Look only for points which satisfies this conditions"
          },
          "params": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SearchParams"
              },
              {
                "nullable": true
              }
            ],
            "description": "Additional search params"
          },
          "top": {
            "description": "Max number of result to return",
            "format": "uint",
            "minimum": 0,
            "type": "integer"
          },
          "vector": {
            "description": "Look for vectors closest to this",
            "items": {
              "format": "float",
              "type": "number"
            },
            "type": "array"
          }
        },
        "required": [
          "top",
          "vector"
        ],
        "type": "object"
      },
      "StorageOperations": {
        "anyOf": [
          {
            "additionalProperties": false,
            "description": "Create new collection and (optionally) specify index params",
            "properties": {
              "create_collection": {
                "properties": {
                  "distance": {
                    "$ref": "#/components/schemas/Distance"
                  },
                  "hnsw_config": {
                    "anyOf": [
                      {
                        "$ref": "#/components/schemas/HnswConfigDiff"
                      },
                      {
                        "nullable": true
                      }
                    ],
                    "description": "Custom params for HNSW index. If none - values from service configuration file are used."
                  },
                  "name": {
                    "type": "string"
                  },
                  "optimizers_config": {
                    "anyOf": [
                      {
                        "$ref": "#/components/schemas/OptimizersConfigDiff"
                      },
                      {
                        "nullable": true
                      }
                    ],
                    "description": "Custom params for Optimizers.  If none - values from service configuration file are used."
                  },
                  "vector_size": {
                    "format": "uint",
                    "minimum": 0,
                    "type": "integer"
                  },
                  "wal_config": {
                    "anyOf": [
                      {
                        "$ref": "#/components/schemas/WalConfigDiff"
                      },
                      {
                        "nullable": true
                      }
                    ],
                    "description": "Custom params for WAL. If none - values from service configuration file are used."
                  }
                },
                "required": [
                  "distance",
                  "name",
                  "vector_size"
                ],
                "type": "object"
              }
            },
            "required": [
              "create_collection"
            ],
            "type": "object"
          },
          {
            "additionalProperties": false,
            "description": "Update parameters of the existing collection",
            "properties": {
              "update_collection": {
                "properties": {
                  "name": {
                    "type": "string"
                  },
                  "optimizers_config": {
                    "anyOf": [
                      {
                        "$ref": "#/components/schemas/OptimizersConfigDiff"
                      },
                      {
                        "nullable": true
                      }
                    ],
                    "description": "Custom params for Optimizers.  If none - values from service configuration file are used. This operation is blocking, it will only proceed ones all current optimizations are complete"
                  }
                },
                "required": [
                  "name"
                ],
                "type": "object"
              }
            },
            "required": [
              "update_collection"
            ],
            "type": "object"
          },
          {
            "additionalProperties": false,
            "description": "Delete collection with given name",
            "properties": {
              "delete_collection": {
                "type": "string"
              }
            },
            "required": [
              "delete_collection"
            ],
            "type": "object"
          },
          {
            "additionalProperties": false,
            "description": "Perform changes of collection aliases. Alias changes are atomic, meaning that no collection modifications can happen between alias operations.",
            "properties": {
              "change_aliases": {
                "properties": {
                  "actions": {
                    "items": {
                      "$ref": "#/components/schemas/AliasOperations"
                    },
                    "type": "array"
                  }
                },
                "required": [
                  "actions"
                ],
                "type": "object"
              }
            },
            "required": [
              "change_aliases"
            ],
            "type": "object"
          }
        ]
      },
      "UpdateResult": {
        "properties": {
          "operation_id": {
            "description": "Sequential number of the operation",
            "format": "uint64",
            "minimum": 0,
            "type": "integer"
          },
          "status": {
            "$ref": "#/components/schemas/UpdateStatus"
          }
        },
        "required": [
          "operation_id",
          "status"
        ],
        "type": "object"
      },
      "UpdateStatus": {
        "enum": [
          "acknowledged",
          "completed"
        ],
        "type": "string"
      },
      "WalConfig": {
        "properties": {
          "wal_capacity_mb": {
            "description": "Size of a single WAL segment in MB",
            "format": "uint",
            "minimum": 0,
            "type": "integer"
          },
          "wal_segments_ahead": {
            "description": "Number of WAL segments to create ahead of actually used ones",
            "format": "uint",
            "minimum": 0,
            "type": "integer"
          }
        },
        "required": [
          "wal_capacity_mb",
          "wal_segments_ahead"
        ],
        "type": "object"
      },
      "WalConfigDiff": {
        "properties": {
          "wal_capacity_mb": {
            "description": "Size of a single WAL segment in MB",
            "format": "uint",
            "minimum": 0,
            "nullable": true,
            "type": "integer"
          },
          "wal_segments_ahead": {
            "description": "Number of WAL segments to create ahead of actually used ones",
            "format": "uint",
            "minimum": 0,
            "nullable": true,
            "type": "integer"
          }
        },
        "type": "object"
      }
    }
  },
  "externalDocs": {
    "description": "Find out more about Qdrant aplications and demo",
    "url": "demo.qdrant.tech"
  },
  "info": {
    "contact": {
      "email": "andrey@vasnetsov.com"
    },
    "description": "\nAPI description for Qdrant vector search engine.\n\nThis document describes CRUD and search operations on collections of points (vectors with payload).\n\nQdrant supports any combinations of `should`, `must` and `must_not` conditions, which makes it possible to use in applications when object could not be described solely by vector. It could be location features, availability flags, and other custom properties businesses should take into account.\n## Examples\nThis examples cover the most basic use-cases - collection creation and basic vector search.\n### Create collection\nFirst - let's create a collection with dot-production metric.\n```\ncurl -X POST 'http://localhost:6333/collections' \\\n  -H 'Content-Type: application/json' \\\n  --data-raw '{\n      \"create_collection\": {\n          \"name\": \"test_collection\",\n          \"vector_size\": 4,\n          \"distance\": \"Dot\"\n      }\n  }'\n```\nExpected response:\n```\n{\n    \"result\": true,\n    \"status\": \"ok\",\n    \"time\": 0.031095451\n}\n```\nWe can ensure that collection was created:\n```\ncurl 'http://localhost:6333/collections/test_collection'\n```\nExpected response:\n```\n{\n  \"result\": {\n    \"status\": \"green\",\n    \"vectors_count\": 0,\n    \"segments_count\": 5,\n    \"disk_data_size\": 0,\n    \"ram_data_size\": 0,\n    \"config\": {\n      \"params\": {\n        \"vector_size\": 4,\n        \"distance\": \"Dot\"\n      },\n      \"hnsw_config\": {\n        \"m\": 16,\n        \"ef_construct\": 100,\n        \"full_scan_threshold\": 10000\n      },\n      \"optimizer_config\": {\n        \"deleted_threshold\": 0.2,\n        \"vacuum_min_vector_number\": 1000,\n        \"max_segment_number\": 5,\n        \"memmap_threshold\": 50000,\n        \"indexing_threshold\": 20000,\n        \"payload_indexing_threshold\": 10000,\n        \"flush_interval_sec\": 1\n      },\n      \"wal_config\": {\n        \"wal_capacity_mb\": 32,\n        \"wal_segments_ahead\": 0\n      }\n    }\n  },\n  \"status\": \"ok\",\n  \"time\": 2.1199e-05\n}\n```\n\n### Add points\nLet's now add vectors with some payload:\n```\ncurl -L -X POST 'http://localhost:6333/collections/test_collection?wait=true' \\ -H 'Content-Type: application/json' \\ --data-raw '{\n  \"upsert_points\": {\n    \"points\": [\n      {\"id\": 1, \"vector\": [0.05, 0.61, 0.76, 0.74], \"payload\": {\"city\": {\"type\": \"keyword\", \"value\": \"Berlin\"}}},\n      {\"id\": 2, \"vector\": [0.19, 0.81, 0.75, 0.11], \"payload\": {\"city\": {\"type\": \"keyword\", \"value\": [\"Berlin\", \"London\"] }}},\n      {\"id\": 3, \"vector\": [0.36, 0.55, 0.47, 0.94], \"payload\": {\"city\": {\"type\": \"keyword\", \"value\": [\"Berlin\", \"Moscow\"] }}},\n      {\"id\": 4, \"vector\": [0.18, 0.01, 0.85, 0.80], \"payload\": {\"city\": {\"type\": \"keyword\", \"value\": [\"London\", \"Moscow\"]}}},\n      {\"id\": 5, \"vector\": [0.24, 0.18, 0.22, 0.44], \"payload\": {\"count\": {\"type\": \"integer\", \"value\": [0]}}},\n      {\"id\": 6, \"vector\": [0.35, 0.08, 0.11, 0.44]}\n    ]\n  }\n}'\n```\nExpected response:\n```\n{\n    \"result\": {\n        \"operation_id\": 0,\n        \"status\": \"completed\"\n    },\n    \"status\": \"ok\",\n    \"time\": 0.000206061\n}\n```\n### Search with filtering\nLet's start with a basic request:\n```\ncurl -L -X POST 'http://localhost:6333/collections/test_collection/points/search' \\ -H 'Content-Type: application/json' \\ --data-raw '{\n    \"vector\": [0.2,0.1,0.9,0.7],\n    \"top\": 3\n}'\n```\nExpected response:\n```\n{\n    \"result\": [\n        { \"id\": 4, \"score\": 1.362 },\n        { \"id\": 1, \"score\": 1.273 },\n        { \"id\": 3, \"score\": 1.208 }\n    ],\n    \"status\": \"ok\",\n    \"time\": 0.000055785\n}\n```\nBut result is different if we add a filter:\n```\ncurl -L -X POST 'http://localhost:6333/collections/test_collection/points/search' \\ -H 'Content-Type: application/json' \\ --data-raw '{\n    \"filter\": {\n        \"should\": [\n            {\n                \"key\": \"city\",\n                \"match\": {\n                    \"keyword\": \"London\"\n                }\n            }\n        ]\n    },\n    \"vector\": [0.2, 0.1, 0.9, 0.7],\n    \"top\": 3\n}'\n```\nExpected response:\n```\n{\n    \"result\": [\n        { \"id\": 4, \"score\": 1.362 },\n        { \"id\": 2, \"score\": 0.871 }\n    ],\n    \"status\": \"ok\",\n    \"time\": 0.000093972\n}\n```\n",
    "license": {
      "name": "Apache 2.0",
      "url": "http://www.apache.org/licenses/LICENSE-2.0.html"
    },
    "title": "Qdrant API",
    "version": "0.3.5"
  },
  "openapi": "3.0.1",
  "paths": {
    "/collections": {
      "get": {
        "operationId": "get_collections",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "result": {
                      "$ref": "#/components/schemas/CollectionsResponse"
                    },
                    "status": {
                      "enum": [
                        "ok"
                      ],
                      "type": "string"
                    },
                    "time": {
                      "description": "Time spent to process this request",
                      "format": "float",
                      "type": "number"
                    }
                  },
                  "type": "object"
                }
              }
            },
            "description": "successful operation"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "error"
          }
        },
        "summary": "Get list of existing collections",
        "tags": [
          "collections"
        ]
      },
      "post": {
        "operationId": "update_collections",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/StorageOperations"
              }
            }
          },
          "description": "Operation to perform on collections"
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "result": {
                      "type": "boolean"
                    },
                    "status": {
                      "enum": [
                        "ok"
                      ],
                      "type": "string"
                    },
                    "time": {
                      "description": "Time spent to process this request",
                      "format": "float",
                      "type": "number"
                    }
                  },
                  "type": "object"
                }
              }
            },
            "description": "successful operation"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "error"
          }
        },
        "summary": "Perform update operation on collections",
        "tags": [
          "collections"
        ]
      }
    },
    "/collections/{name}": {
      "get": {
        "operationId": "get_collection",
        "parameters": [
          {
            "description": "Name of the collection to retrieve",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "result": {
                      "$ref": "#/components/schemas/CollectionInfo"
                    },
                    "status": {
                      "enum": [
                        "ok"
                      ],
                      "type": "string"
                    },
                    "time": {
                      "description": "Time spent to process this request",
                      "format": "float",
                      "type": "number"
                    }
                  },
                  "type": "object"
                }
              }
            },
            "description": "successful operation"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "error"
          }
        },
        "summary": "Get information about existing collection",
        "tags": [
          "collections"
        ]
      },
      "post": {
        "operationId": "update_points",
        "parameters": [
          {
            "description": "Name of the collection to search in",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Wait for changes to actually happen? Default: false",
            "in": "query",
            "name": "wait",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CollectionUpdateOperations"
              }
            }
          },
          "description": "Collection update operations"
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "result": {
                      "$ref": "#/components/schemas/UpdateResult"
                    },
                    "status": {
                      "enum": [
                        "ok"
                      ],
                      "type": "string"
                    },
                    "time": {
                      "description": "Time spent to process this request",
                      "format": "float",
                      "type": "number"
                    }
                  },
                  "type": "object"
                }
              }
            },
            "description": "successful operation"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "error"
          }
        },
        "summary": "Update points (vectors, payloads, indexes) in collection",
        "tags": [
          "points"
        ]
      }
    },
    "/collections/{name}/points": {
      "post": {
        "operationId": "get_points",
        "parameters": [
          {
            "description": "Name of the collection to retrieve from",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PointRequest"
              }
            }
          },
          "description": "List of points to retrieve"
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "result": {
                      "items": {
                        "$ref": "#/components/schemas/Record"
                      },
                      "type": "array"
                    },
                    "status": {
                      "enum": [
                        "ok"
                      ],
                      "type": "string"
                    },
                    "time": {
                      "description": "Time spent to process this request",
                      "format": "float",
                      "type": "number"
                    }
                  },
                  "type": "object"
                }
              }
            },
            "description": "successful operation"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "error"
          }
        },
        "summary": "Retrieve points by ids",
        "tags": [
          "points"
        ]
      }
    },
    "/collections/{name}/points/recommend": {
      "post": {
        "operationId": "recommend_points",
        "parameters": [
          {
            "description": "Name of the collection to search in",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RecommendRequest"
              }
            }
          },
          "description": "Request points based on positive and negative examples."
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "result": {
                      "items": {
                        "$ref": "#/components/schemas/ScoredPoint"
                      },
                      "type": "array"
                    },
                    "status": {
                      "enum": [
                        "ok"
                      ],
                      "type": "string"
                    },
                    "time": {
                      "description": "Time spent to process this request",
                      "format": "float",
                      "type": "number"
                    }
                  },
                  "type": "object"
                }
              }
            },
            "description": "successful operation"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "error"
          }
        },
        "summary": "Recommend points",
        "tags": [
          "points"
        ]
      }
    },
    "/collections/{name}/points/scroll": {
      "post": {
        "description": "Scroll request - paginate over all points which matches given condition",
        "operationId": "scroll_points",
        "parameters": [
          {
            "description": "Name of the collection to retrieve from",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ScrollRequest"
              }
            }
          },
          "description": "Pagination and filter parameters"
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "result": {
                      "$ref": "#/components/schemas/ScrollResult"
                    },
                    "status": {
                      "enum": [
                        "ok"
                      ],
                      "type": "string"
                    },
                    "time": {
                      "description": "Time spent to process this request",
                      "format": "float",
                      "type": "number"
                    }
                  },
                  "type": "object"
                }
              }
            },
            "description": "successful operation"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "error"
          }
        },
        "summary": "Scroll points",
        "tags": [
          "points"
        ]
      }
    },
    "/collections/{name}/points/search": {
      "post": {
        "operationId": "search_points",
        "parameters": [
          {
            "description": "Name of the collection to search in",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SearchRequest"
              }
            }
          },
          "description": "Search request with optional filtering"
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "result": {
                      "items": {
                        "$ref": "#/components/schemas/ScoredPoint"
                      },
                      "type": "array"
                    },
                    "status": {
                      "enum": [
                        "ok"
                      ],
                      "type": "string"
                    },
                    "time": {
                      "description": "Time spent to process this request",
                      "format": "float",
                      "type": "number"
                    }
                  },
                  "type": "object"
                }
              }
            },
            "description": "successful operation"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "error"
          }
        },
        "summary": "Search points",
        "tags": [
          "points"
        ]
      }
    },
    "/collections/{name}/points/{id}": {
      "get": {
        "operationId": "get_point",
        "parameters": [
          {
            "description": "Name of the collection to retrieve from",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Id of the point",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "result": {
                      "$ref": "#/components/schemas/Record"
                    },
                    "status": {
                      "enum": [
                        "ok"
                      ],
                      "type": "string"
                    },
                    "time": {
                      "description": "Time spent to process this request",
                      "format": "float",
                      "type": "number"
                    }
                  },
                  "type": "object"
                }
              }
            },
            "description": "successful operation"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "error"
          }
        },
        "summary": "Retrieve point by id",
        "tags": [
          "points"
        ]
      }
    }
  },
  "servers": [
    {
      "url": "http://localhost:6333"
    }
  ],
  "tags": [
    {
      "description": "Searchable collections of points.",
      "name": "collections"
    },
    {
      "description": "Float-point vectors with payload.",
      "name": "points"
    }
  ]
}
